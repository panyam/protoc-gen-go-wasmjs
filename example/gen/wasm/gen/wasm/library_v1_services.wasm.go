//go:build js && wasm
// +build js,wasm

// Code generated by protoc-gen-go-wasmjs. DO NOT EDIT.
// source: library/v1/library.proto

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"syscall/js"
	"time"

	"google.golang.org/protobuf/encoding/protojson"
	libraryv1 "github.com/panyam/protoc-gen-go-wasmjs/example/gen/go/library/v1"
)

// Global service implementations
var globalServices = struct {
	LibraryService libraryv1.LibraryServiceServer
	UserService    libraryv1.UserServiceServer
}{}

func main() {
	fmt.Println("library_v1_services WASM module loading...")
	// Create namespaced API structure
	library := map[string]interface{}{
		"libraryService": map[string]interface{}{
			"findBooks":    js.FuncOf(libraryServiceFindBooks),
			"checkoutBook": js.FuncOf(libraryServiceCheckoutBook),
			"returnBook":   js.FuncOf(libraryServiceReturnBook),
			"getUserBooks": js.FuncOf(libraryServiceGetUserBooks),
		},
		"userService": map[string]interface{}{
			"getUser":    js.FuncOf(userServiceGetUser),
			"createUser": js.FuncOf(userServiceCreateUser),
		},
	}
	js.Global().Set("library", js.ValueOf(library))

	fmt.Println("library_v1_services WASM module loaded successfully")

	// Keep the program running
	c := make(chan struct{})
	<-c
}

// Service initialization functions
func SetLibraryService(impl libraryv1.LibraryServiceServer) {
	globalServices.LibraryService = impl
}
func SetUserService(impl libraryv1.UserServiceServer) {
	globalServices.UserService = impl
}

// =============================================================================
// WASM API Functions - Generated Method Wrappers
// =============================================================================

// libraryServiceFindBooks handles the FindBooks method for LibraryService
func libraryServiceFindBooks(this js.Value, args []js.Value) any {
	if globalServices.LibraryService == nil {
		return createJSResponse(false, "LibraryService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *libraryv1.FindBooksRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := globalServices.LibraryService.FindBooks(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// libraryServiceCheckoutBook handles the CheckoutBook method for LibraryService
func libraryServiceCheckoutBook(this js.Value, args []js.Value) any {
	if globalServices.LibraryService == nil {
		return createJSResponse(false, "LibraryService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *libraryv1.CheckoutBookRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := globalServices.LibraryService.CheckoutBook(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// libraryServiceReturnBook handles the ReturnBook method for LibraryService
func libraryServiceReturnBook(this js.Value, args []js.Value) any {
	if globalServices.LibraryService == nil {
		return createJSResponse(false, "LibraryService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *libraryv1.ReturnBookRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := globalServices.LibraryService.ReturnBook(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// libraryServiceGetUserBooks handles the GetUserBooks method for LibraryService
func libraryServiceGetUserBooks(this js.Value, args []js.Value) any {
	if globalServices.LibraryService == nil {
		return createJSResponse(false, "LibraryService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *libraryv1.GetUserBooksRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := globalServices.LibraryService.GetUserBooks(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// userServiceGetUser handles the GetUser method for UserService
func userServiceGetUser(this js.Value, args []js.Value) any {
	if globalServices.UserService == nil {
		return createJSResponse(false, "UserService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *libraryv1.GetUserRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := globalServices.UserService.GetUser(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// userServiceCreateUser handles the CreateUser method for UserService
func userServiceCreateUser(this js.Value, args []js.Value) any {
	if globalServices.UserService == nil {
		return createJSResponse(false, "UserService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *libraryv1.CreateUserRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := globalServices.UserService.CreateUser(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// =============================================================================
// Helper Functions
// =============================================================================

// createJSResponse creates a JavaScript-compatible response
func createJSResponse(success bool, message string, data any) any {
	response := map[string]any{
		"success": success,
		"message": message,
		"data":    data,
	}

	// Convert to JS Value
	responseBytes, err := json.Marshal(response)
	if err != nil {
		fmt.Printf("Failed to marshal JSON response: %v\n", err)
		// Return a simple error response
		errorResponse := map[string]any{
			"success": false,
			"message": fmt.Sprintf("JSON marshal error: %v", err),
			"data":    nil,
		}
		errorBytes, _ := json.Marshal(errorResponse)
		return js.Global().Get("JSON").Call("parse", string(errorBytes))
	}

	return js.Global().Get("JSON").Call("parse", string(responseBytes))
}
