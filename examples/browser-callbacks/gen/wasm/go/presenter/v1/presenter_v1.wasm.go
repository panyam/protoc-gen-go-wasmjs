//go:build js && wasm
// +build js,wasm

// Code generated by protoc-gen-go-wasmjs. DO NOT EDIT.
// source: presenter/v1/presenter.proto

package presenter_v1_services

import (
	"context"
	"encoding/json"
	"fmt"
	"syscall/js"
	"time"

	presenterv1 "github.com/panyam/protoc-gen-go-wasmjs/examples/browser-callbacks/gen/go/presenter/v1"
	"google.golang.org/grpc/metadata"
	"google.golang.org/protobuf/encoding/protojson"
)

// Presenter_v1ServicesExports provides WASM exports for dependency injection
type Presenter_v1ServicesExports struct {
	PresenterService presenterv1.PresenterServiceServer
}

// RegisterAPI registers the services with the JavaScript global namespace
func (exports *Presenter_v1ServicesExports) RegisterAPI() {
	fmt.Println("presenter_v1_services WASM module loading...")
	// Create namespaced API structure
	presenter_v1 := map[string]interface{}{
		"presenterService": map[string]interface{}{
			"loadUserData": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.presenterServiceLoadUserData(this, args)
			}),
			"updateUIState": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.presenterServiceUpdateUIState(this, args)
			}),
			"savePreferences": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.presenterServiceSavePreferences(this, args)
			}),
			"runCallbackDemo": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.presenterServiceRunCallbackDemo(this, args)
			}),
		},
	}
	js.Global().Set("presenter_v1", js.ValueOf(presenter_v1))

	fmt.Println("presenter_v1_services WASM module loaded successfully")
}

// =============================================================================
// WASM API Functions - Generated Method Wrappers
// =============================================================================

// presenterServiceLoadUserData handles the LoadUserData method for PresenterService
func (exports *Presenter_v1ServicesExports) presenterServiceLoadUserData(this js.Value, args []js.Value) any {
	if exports.PresenterService == nil {
		return createJSResponse(false, "PresenterService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &presenterv1.LoadUserRequest{}
	opts := protojson.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}
	if err := opts.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.PresenterService.LoadUserData(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	marshalOpts := protojson.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	}
	responseJSON, err := marshalOpts.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// presenterServiceUpdateUIState handles the UpdateUIState method for PresenterService
func (exports *Presenter_v1ServicesExports) presenterServiceUpdateUIState(this js.Value, args []js.Value) any {
	if exports.PresenterService == nil {
		return createJSResponse(false, "PresenterService not initialized", nil)
	}
	// Server streaming method: expect request JSON and callback function
	if len(args) < 2 {
		return createJSResponse(false, "Request JSON and callback function required for streaming method", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	callback := args[1]
	if callback.Type() != js.TypeFunction {
		return createJSResponse(false, "Second argument must be a callback function", nil)
	}

	// Parse request
	req := &presenterv1.StateUpdateRequest{}
	opts := protojson.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true,
	}
	if err := opts.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Start streaming in goroutine to avoid blocking
	go func() {
		ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
		defer cancel()

		// Create a stream wrapper for server-side streaming
		streamWrapper := &serverStreamWrapperUpdateUIState{
			ctx:      ctx,
			callback: callback,
		}

		// Call the server streaming method
		err := exports.PresenterService.UpdateUIState(req, streamWrapper)
		if err != nil {
			// Call callback with error and done=true
			callback.Invoke(js.Null(), err.Error(), true)
			return
		}

		// Signal completion
		callback.Invoke(js.Null(), js.Null(), true)
	}()

	// Return immediately for streaming methods
	return createJSResponse(true, "Server streaming started", nil)
}

// presenterServiceSavePreferences handles the SavePreferences method for PresenterService
func (exports *Presenter_v1ServicesExports) presenterServiceSavePreferences(this js.Value, args []js.Value) any {
	if exports.PresenterService == nil {
		return createJSResponse(false, "PresenterService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &presenterv1.PreferencesRequest{}
	opts := protojson.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}
	if err := opts.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.PresenterService.SavePreferences(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	marshalOpts := protojson.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	}
	responseJSON, err := marshalOpts.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// presenterServiceRunCallbackDemo handles the RunCallbackDemo method for PresenterService
func (exports *Presenter_v1ServicesExports) presenterServiceRunCallbackDemo(this js.Value, args []js.Value) any {
	if exports.PresenterService == nil {
		return createJSResponse(false, "PresenterService not initialized", nil)
	}
	// Synchronous method
	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &presenterv1.CallbackDemoRequest{}
	opts := protojson.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}
	if err := opts.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.PresenterService.RunCallbackDemo(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	marshalOpts := protojson.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	}
	responseJSON, err := marshalOpts.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// =============================================================================
// Server Stream Wrappers
// =============================================================================

// serverStreamWrapperUpdateUIState implements the server stream interface for UpdateUIState
type serverStreamWrapperUpdateUIState struct {
	ctx      context.Context
	callback js.Value
}

func (s *serverStreamWrapperUpdateUIState) Send(resp *presenterv1.UIUpdate) error {
	// Marshal response
	marshalOpts := protojson.MarshalOptions{
		UseProtoNames:   false,
		EmitUnpopulated: false,
		UseEnumNumbers:  false,
	}
	responseJSON, err := marshalOpts.Marshal(resp)
	if err != nil {
		s.callback.Invoke(js.Null(), fmt.Sprintf("Failed to marshal response: %v", err), true)
		return err
	}

	// Call callback with response, no error, not done - returns boolean to continue
	shouldContinue := s.callback.Invoke(string(responseJSON), js.Null(), false)

	// Check if JS wants to stop the stream
	if !shouldContinue.Bool() {
		return fmt.Errorf("stream cancelled by client")
	}

	return nil
}

func (s *serverStreamWrapperUpdateUIState) Context() context.Context {
	return s.ctx
}

// Implement other required methods for the stream interface
func (s *serverStreamWrapperUpdateUIState) SetHeader(metadata.MD) error  { return nil }
func (s *serverStreamWrapperUpdateUIState) SendHeader(metadata.MD) error { return nil }
func (s *serverStreamWrapperUpdateUIState) SetTrailer(metadata.MD)       {}
func (s *serverStreamWrapperUpdateUIState) SendMsg(m interface{}) error {
	if msg, ok := m.(*presenterv1.UIUpdate); ok {
		return s.Send(msg)
	}
	return fmt.Errorf("unexpected message type")
}
func (s *serverStreamWrapperUpdateUIState) RecvMsg(m interface{}) error { return nil }

// =============================================================================
// Helper Functions
// =============================================================================

// createJSResponse is a wrapper for the library function
func createJSResponse(success bool, message string, data any) any {
	// Inline implementation when no browser services (no wasm import)
	response := map[string]any{
		"success": success,
		"message": message,
		"data":    data,
	}

	responseBytes, err := json.Marshal(response)
	if err != nil {
		fmt.Printf("Failed to marshal JSON response: %v\n", err)
		errorResponse := map[string]any{
			"success": false,
			"message": fmt.Sprintf("JSON marshal error: %v", err),
			"data":    nil,
		}
		errorBytes, _ := json.Marshal(errorResponse)
		return js.Global().Get("JSON").Call("parse", string(errorBytes))
	}

	return js.Global().Get("JSON").Call("parse", string(responseBytes))
}
