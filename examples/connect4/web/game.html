<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connect4 - Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .game-container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            padding: 30px;
            max-width: 1000px;
            width: 100%;
        }

        .game-nav {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .game-nav h2 {
            margin: 0;
            font-size: 1.5rem;
        }

        .game-url {
            font-family: monospace;
            background: #f3f4f6;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #d1d5db;
            font-size: 0.8rem;
        }

        .btn {
            padding: 12px 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: background 0.2s ease;
            text-decoration: none;
            display: inline-block;
            text-align: center;
        }

        .btn:hover {
            background: #5a67d8;
        }

        .btn:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
        }

        .btn-back {
            background: #6b7280;
            padding: 8px 16px;
            font-size: 0.9rem;
        }

        .btn-back:hover {
            background: #4b5563;
        }

        .btn-secondary {
            background: #6b7280;
        }

        .btn-secondary:hover {
            background: #4b5563;
        }

        .join-form {
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .form-group input {
            width: 100%;
            padding: 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 1rem;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .player-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #333;
        }

        .game-status {
            font-weight: bold;
            font-size: 1.1rem;
        }

        .board-container {
            margin: 20px 0;
            display: flex;
            justify-content: center;
        }

        .board {
            background: #1e40af;
            border-radius: 10px;
            padding: 10px;
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            min-height: 300px;
        }

        .cell {
            width: 50px;
            height: 50px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid #1e40af;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cell:hover {
            background: #60a5fa;
        }

        .cell.occupied {
            cursor: not-allowed;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }

        .players-list {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .players-list h3 {
            margin-bottom: 10px;
        }

        .player-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            border-bottom: 1px solid #e5e7eb;
        }

        .player-item:last-child {
            border-bottom: none;
        }

        .log {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            max-height: 200px;
            overflow-y: auto;
        }

        .log h3 {
            margin-bottom: 10px;
        }

        .log-entry {
            padding: 5px 0;
            font-size: 0.9rem;
            color: #6b7280;
            border-bottom: 1px solid #e5e7eb;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .winning-line {
            background: #ffd700 !important;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .hidden {
            display: none;
        }

        .error-state {
            text-align: center;
            padding: 60px 20px;
            color: #ef4444;
        }

        .error-state h3 {
            font-size: 1.3rem;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üî¥ Connect4 Multiplayer</h1>
        <p>Real-time collaborative gaming with stateful proxies</p>
    </div>

    <div class="game-container">
        <div class="game-nav">
            <a href="games.html" class="btn btn-back">‚Üê Back to Games</a>
            <h2>Game: <span id="currentGameId"></span></h2>
            <div class="game-url">
                <small>Share this URL: <span id="gameUrl"></span></small>
            </div>
        </div>

        <!-- Error state for invalid game URLs -->
        <div id="errorState" class="error-state hidden">
            <h3>Game not found</h3>
            <p>Please check the URL or create a new game.</p>
            <div style="margin-top: 20px;">
                <a href="games.html" class="btn">Back to Games</a>
            </div>
        </div>

        <!-- Join Form for specific game -->
        <div id="joinGameForm" class="join-form hidden">
            <h3>Join Game</h3>
            <div class="form-group">
                <label for="playerName">Your Name:</label>
                <input type="text" id="playerName" placeholder="Enter your name" required>
            </div>
            <div class="controls">
                <button class="btn" onclick="joinCurrentGame()">Join Game</button>
            </div>
        </div>

        <!-- Game Interface -->
        <div id="gameInterface" class="hidden">
            <div class="game-info">
                <div class="player-info">
                    <span>Current Player:</span>
                    <div id="currentPlayerColor" class="player-color"></div>
                    <span id="currentPlayerName">Waiting...</span>
                </div>
                <div class="game-status" id="gameStatus">Waiting for players...</div>
                <div>Turn: <span id="turnNumber">0</span></div>
            </div>

            <div class="board-container">
                <div id="gameBoard" class="board">
                    <!-- Board cells will be generated by JavaScript -->
                </div>
            </div>

            <div class="controls">
                <button class="btn" onclick="resetGame()">New Game</button>
                <button class="btn btn-secondary" onclick="leaveGame()">Leave Game</button>
            </div>

            <div class="players-list">
                <h3>Players</h3>
                <div id="playersList"></div>
            </div>

            <div class="log">
                <h3>Game Log</h3>
                <div id="gameLog"></div>
            </div>
        </div>
    </div>

    <!-- Load the generated TypeScript client and protobuf types -->
    <script type="module">
        // Import the generated WASM client and protobuf types
        import Connect4_gameClient from './gen/wasm/connect4-game/connect4_gameClient.client.js';
        import { GameState, GameConfig, GameStatus } from './gen/ts/connect4/game_pb.js';
        
        // Make them available globally for the main script
        window.Connect4Client = Connect4_gameClient;
        window.GameState = GameState;
        window.GameConfig = GameConfig;
        window.GameStatus = GameStatus;
    </script>

    <script>
        // Application state
        let gameState = null;
        let currentPlayerId = null;
        let currentGameId = null;
        let connect4Client = null;

        // UI Elements
        const joinGameForm = document.getElementById('joinGameForm');
        const gameInterface = document.getElementById('gameInterface');
        const errorState = document.getElementById('errorState');
        const gameBoard = document.getElementById('gameBoard');
        const gameStatus = document.getElementById('gameStatus');
        const currentPlayerName = document.getElementById('currentPlayerName');
        const currentPlayerColor = document.getElementById('currentPlayerColor');
        const turnNumber = document.getElementById('turnNumber');
        const playersList = document.getElementById('playersList');
        const gameLog = document.getElementById('gameLog');

        // Initialize WASM client
        async function initializeWasmClient() {
            try {
                addLogEntry('Loading WASM module...');
                connect4Client = new window.Connect4Client();
                await connect4Client.loadWasm('./multiplayer_connect4.wasm');
                await connect4Client.waitUntilReady();
                addLogEntry('WASM module loaded successfully!');
                return true;
            } catch (error) {
                console.error('Failed to load WASM:', error);
                addLogEntry(`Failed to load WASM module: ${error.message}`);
                return false;
            }
        }

        // Get URL parameters
        function getUrlParameter(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }

        // Game state management
        function loadGameState(gameId) {
            const stored = localStorage.getItem(`connect4_game_${gameId}`);
            if (stored) {
                try {
                    return JSON.parse(stored);
                } catch (e) {
                    console.error('Failed to parse stored game state:', e);
                }
            }
            return null;
        }

        function saveGameState(gameId, state) {
            localStorage.setItem(`connect4_game_${gameId}`, JSON.stringify(state));
            // Trigger storage event for other windows
            window.dispatchEvent(new CustomEvent('gameStateChanged', { detail: { gameId, state } }));
        }

        function deleteGameState(gameId) {
            localStorage.removeItem(`connect4_game_${gameId}`);
            window.dispatchEvent(new CustomEvent('gameStateChanged', { detail: { gameId, state: null } }));
        }

        // Listen for game state changes from other windows
        window.addEventListener('gameStateChanged', function(e) {
            const { gameId, state } = e.detail;
            if (gameId === currentGameId) {
                if (!state) {
                    // Game was deleted
                    addLogEntry(`Game "${gameId}" was deleted - all players have left`);
                    setTimeout(() => {
                        window.location.href = 'games.html';
                    }, 2000);
                } else if (gameState) {
                    // Game state updated
                    gameState = state;
                    updateUI();
                    addLogEntry('Game state updated from another window');
                }
            }
        });

        // Also listen for localStorage changes from other windows
        window.addEventListener('storage', function(e) {
            if (e.key === `connect4_game_${currentGameId}`) {
                const newState = e.newValue ? JSON.parse(e.newValue) : null;
                if (!newState) {
                    addLogEntry(`Game "${currentGameId}" was deleted - all players have left`);
                    setTimeout(() => {
                        window.location.href = 'games.html';
                    }, 2000);
                } else if (gameState) {
                    gameState = newState;
                    updateUI();
                    addLogEntry('Game state updated from another window');
                }
            }
        });

        // Page initialization
        async function initializePage() {
            currentGameId = getUrlParameter('gameId');
            const playerId = getUrlParameter('playerId');

            if (!currentGameId) {
                showErrorState();
                return;
            }

            // Initialize WASM client first
            const wasmReady = await initializeWasmClient();
            if (!wasmReady) {
                showErrorState();
                return;
            }

            document.getElementById('currentGameId').textContent = currentGameId;
            document.getElementById('gameUrl').textContent = window.location.href.split('?')[0] + '?gameId=' + currentGameId;

            // Try to get game state from WASM service
            try {
                const wasmGameState = await connect4Client.connect4Service.getGame({ gameId: currentGameId });
                if (wasmGameState) {
                    gameState = wasmGameState;
                    // Check if user was already in this game
                    if (playerId && gameState.players.some(p => p.id === playerId)) {
                        currentPlayerId = playerId;
                        showGameInterface();
                        addLogEntry(`Reconnected as ${gameState.players.find(p => p.id === playerId).name}`);
                    } else {
                        showJoinForm();
                    }
                } else {
                    // Game doesn't exist in WASM service yet
                    showJoinForm();
                }
            } catch (error) {
                console.log('Game not found in WASM service, will create new one');
                showJoinForm();
            }

            // Set up periodic sync with localStorage for cross-tab communication
            startLocalStorageSync();
        }

        function showErrorState() {
            errorState.classList.remove('hidden');
            joinGameForm.classList.add('hidden');
            gameInterface.classList.add('hidden');
        }

        function showJoinForm() {
            joinGameForm.classList.remove('hidden');
            gameInterface.classList.add('hidden');
            errorState.classList.add('hidden');
        }

        function showGameInterface() {
            joinGameForm.classList.add('hidden');
            gameInterface.classList.remove('hidden');
            errorState.classList.add('hidden');
            initializeBoard(gameState.config.boardWidth, gameState.config.boardHeight);
            updateUI();
        }

        // Join current game - now calls WASM service
        async function joinCurrentGame() {
            const playerName = document.getElementById('playerName').value;
            
            if (!playerName) {
                alert('Please enter your name');
                return;
            }

            if (!connect4Client) {
                alert('WASM module not loaded. Please refresh the page.');
                return;
            }

            try {
                addLogEntry(`Joining game "${currentGameId}" as ${playerName}...`);

                // Try to join existing game first
                let response = await connect4Client.connect4Service.joinGame({
                    gameId: currentGameId,
                    playerName: playerName,
                    preferredColor: '' // Let service assign color
                });

                if (response.success) {
                    currentPlayerId = response.playerId;
                    gameState = response.gameState;
                    
                    // Update URL with player ID for reconnection
                    const newUrl = `${window.location.pathname}?gameId=${currentGameId}&playerId=${currentPlayerId}`;
                    window.history.replaceState({}, '', newUrl);
                    
                    // Save to localStorage for cross-tab sync
                    saveGameStateToLocalStorage(currentGameId, gameState);
                    
                    showGameInterface();
                    addLogEntry(`Successfully joined game! You are ${playerName} (${response.assignedColor})`);

                    if (gameState.status === 'IN_PROGRESS') {
                        addLogEntry('Game started! Enough players have joined.');
                    }
                } else {
                    // Join failed, try to create the game
                    addLogEntry('Game not found, creating new game...');
                    await createNewGameAndJoin(currentGameId, playerName);
                }

            } catch (error) {
                console.error('Error joining game:', error);
                addLogEntry(`Failed to join game: ${error.message}`);
                
                // Fallback: try to create new game
                try {
                    await createNewGameAndJoin(currentGameId, playerName);
                } catch (createError) {
                    console.error('Error creating game:', createError);
                    addLogEntry(`Failed to create game: ${createError.message}`);
                    alert('Failed to join or create game. Please try again.');
                }
            }
        }

        async function createNewGameAndJoin(gameId, playerName) {
            try {
                addLogEntry(`Creating new game "${gameId}"...`);

                const response = await connect4Client.connect4Service.createGame({
                    gameId: gameId,
                    config: {
                        boardWidth: 7,
                        boardHeight: 6,
                        minPlayers: 2,
                        maxPlayers: 4,
                        connectLength: 4,
                        allowMultipleWinners: false,
                        moveTimeoutSeconds: 30
                    },
                    creatorName: playerName
                });

                if (response.success) {
                    currentPlayerId = response.playerId;
                    gameState = response.gameState;
                    
                    // Update URL with player ID
                    const newUrl = `${window.location.pathname}?gameId=${gameId}&playerId=${currentPlayerId}`;
                    window.history.replaceState({}, '', newUrl);
                    
                    // Save to localStorage for cross-tab sync
                    saveGameStateToLocalStorage(gameId, gameState);
                    
                    showGameInterface();
                    addLogEntry(`Game "${gameId}" created successfully! You are the first player.`);
                    addLogEntry('Waiting for more players to start...');
                } else {
                    throw new Error(response.errorMessage || 'Failed to create game');
                }
            } catch (error) {
                console.error('Error creating game:', error);
                throw error;
            }
        }

        // Initialize the board
        function initializeBoard(width = 7, height = 6) {
            gameBoard.innerHTML = '';
            gameBoard.style.gridTemplateColumns = `repeat(${width}, 1fr)`;
            
            for (let row = 0; row < height; row++) {
                for (let col = 0; col < width; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.onclick = () => dropPiece(col);
                    gameBoard.appendChild(cell);
                }
            }
        }

        // Update the UI with current game state
        function updateUI() {
            if (!gameState) return;

            // Update game status
            gameStatus.textContent = getStatusText(gameState.status);
            turnNumber.textContent = gameState.turnNumber;

            // Update current player info
            if (gameState.currentPlayerId) {
                const currentPlayer = gameState.players.find(p => p.id === gameState.currentPlayerId);
                if (currentPlayer) {
                    currentPlayerName.textContent = currentPlayer.name;
                    currentPlayerColor.style.backgroundColor = currentPlayer.color;
                }
            }

            // Update board
            updateBoard();

            // Update players list
            updatePlayersList();
        }

        // Update the board display
        function updateBoard() {
            const cells = gameBoard.querySelectorAll('.cell');
            
            cells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const playerId = gameState.board.rows[row].cells[col];
                
                if (playerId) {
                    const player = gameState.players.find(p => p.id === playerId);
                    if (player) {
                        cell.style.backgroundColor = player.color;
                        cell.classList.add('occupied');
                    }
                } else {
                    cell.style.backgroundColor = '#3b82f6';
                    cell.classList.remove('occupied');
                }
            });
        }

        // Update players list
        function updatePlayersList() {
            playersList.innerHTML = '';
            
            gameState.players.forEach(player => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player-item';
                
                const colorDiv = document.createElement('div');
                colorDiv.className = 'player-color';
                colorDiv.style.backgroundColor = player.color;
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = player.name;
                if (player.id === currentPlayerId) {
                    nameSpan.textContent += ' (You)';
                }
                
                const statusSpan = document.createElement('span');
                statusSpan.textContent = player.isConnected ? ' ‚Ä¢ Online' : ' ‚Ä¢ Offline';
                statusSpan.style.color = player.isConnected ? '#10b981' : '#ef4444';
                
                playerDiv.appendChild(colorDiv);
                playerDiv.appendChild(nameSpan);
                playerDiv.appendChild(statusSpan);
                playersList.appendChild(playerDiv);
            });
        }

        // Drop a piece in the specified column
        async function dropPiece(column) {
            if (!gameState || gameState.status !== 'IN_PROGRESS') {
                addLogEntry('Game is not in progress');
                return;
            }

            if (gameState.currentPlayerId !== currentPlayerId) {
                addLogEntry('It\'s not your turn');
                return;
            }

            if (gameState.board.columnHeights[column] >= gameState.config.boardHeight) {
                addLogEntry('Column is full');
                return;
            }

            try {
                // Simulate piece drop (in real implementation, this would call WASM service)
                const row = gameState.config.boardHeight - 1 - gameState.board.columnHeights[column];
                
                // Place the piece
                gameState.board.rows[row].cells[column] = currentPlayerId;
                gameState.board.columnHeights[column]++;
                
                // Check for winning lines
                const winningLines = checkForWinningLines(row, column, currentPlayerId);
                
                if (winningLines.length > 0) {
                    gameState.winners.push(currentPlayerId);
                    gameState.status = 'FINISHED';
                    highlightWinningLines(winningLines);
                    
                    const player = gameState.players.find(p => p.id === currentPlayerId);
                    addLogEntry(`üéâ ${player.name} wins!`);
                } else {
                    // Advance to next player
                    const currentIndex = gameState.players.findIndex(p => p.id === gameState.currentPlayerId);
                    const nextIndex = (currentIndex + 1) % gameState.players.length;
                    gameState.currentPlayerId = gameState.players[nextIndex].id;
                    gameState.turnNumber++;
                    
                    const player = gameState.players.find(p => p.id === currentPlayerId);
                    const nextPlayer = gameState.players.find(p => p.id === gameState.currentPlayerId);
                    addLogEntry(`${player.name} dropped piece in column ${column + 1}. ${nextPlayer.name}'s turn.`);
                }

                // Save updated game state
                saveGameState(currentGameId, gameState);
                updateUI();

            } catch (error) {
                console.error('Error dropping piece:', error);
                addLogEntry('Failed to drop piece');
            }
        }

        // Check for winning lines (simplified version)
        function checkForWinningLines(row, col, playerId) {
            const lines = [];
            const directions = [
                { dx: 1, dy: 0, name: 'horizontal' },
                { dx: 0, dy: 1, name: 'vertical' },
                { dx: 1, dy: 1, name: 'diagonal_down' },
                { dx: 1, dy: -1, name: 'diagonal_up' }
            ];

            directions.forEach(dir => {
                const positions = [];
                
                // Check both directions from the placed piece
                for (let direction = -1; direction <= 1; direction += 2) {
                    let r = row;
                    let c = col;
                    
                    while (r >= 0 && r < gameState.config.boardHeight && 
                           c >= 0 && c < gameState.config.boardWidth &&
                           gameState.board.rows[r].cells[c] === playerId) {
                        positions.push({ row: r, column: c });
                        r += direction * dir.dy;
                        c += direction * dir.dx;
                    }
                }

                if (positions.length >= gameState.config.connectLength) {
                    lines.push({ positions, direction: dir.name });
                }
            });

            return lines;
        }

        // Highlight winning lines on the board
        function highlightWinningLines(lines) {
            lines.forEach(line => {
                line.positions.forEach(pos => {
                    const cell = document.querySelector(`[data-row="${pos.row}"][data-col="${pos.column}"]`);
                    if (cell) {
                        cell.classList.add('winning-line');
                    }
                });
            });
        }

        // Utility functions
        function getStatusText(status) {
            switch (status) {
                case 'WAITING_FOR_PLAYERS': return 'Waiting for players...';
                case 'IN_PROGRESS': return 'Game in progress';
                case 'FINISHED': return 'Game finished';
                default: return 'Unknown status';
            }
        }

        function addLogEntry(message) {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            gameLog.appendChild(entry);
            gameLog.scrollTop = gameLog.scrollHeight;
        }

        // Game management functions
        function resetGame() {
            if (confirm('Are you sure you want to start a new game?')) {
                if (gameState) {
                    gameState.board.rows.forEach(row => row.cells.fill(''));
                    gameState.board.columnHeights.fill(0);
                    gameState.status = 'IN_PROGRESS';
                    gameState.turnNumber = 0;
                    gameState.winners = [];
                    gameState.currentPlayerId = gameState.players[0].id;
                    
                    saveGameState(currentGameId, gameState);
                    updateUI();
                    addLogEntry('New game started!');
                    
                    // Remove winning line highlights
                    document.querySelectorAll('.winning-line').forEach(cell => {
                        cell.classList.remove('winning-line');
                    });
                }
            }
        }

        function leaveGame() {
            if (confirm('Are you sure you want to leave the game?')) {
                // Remove current player from game state
                if (gameState && currentPlayerId) {
                    gameState.players = gameState.players.filter(p => p.id !== currentPlayerId);
                    
                    // If no players left, delete the game entirely
                    if (gameState.players.length === 0) {
                        deleteGameState(currentGameId);
                        addLogEntry(`Game "${currentGameId}" deleted - all players have left`);
                    } else {
                        // Still have players, just save the updated state
                        saveGameState(currentGameId, gameState);
                        addLogEntry(`You left the game. ${gameState.players.length} player(s) remaining.`);
                    }
                }
                
                // Navigate back to games list
                window.location.href = 'games.html';
            }
        }

        // Initialize the page
        initializePage();
        
        // Auto-refresh game state every 2 seconds for real-time updates
        setInterval(() => {
            if (currentGameId && gameState) {
                const latestState = loadGameState(currentGameId);
                if (latestState && JSON.stringify(latestState) !== JSON.stringify(gameState)) {
                    gameState = latestState;
                    updateUI();
                }
            }
        }, 2000);
    </script>
</body>
</html>
