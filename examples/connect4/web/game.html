<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connect4 - Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .game-container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            padding: 30px;
            max-width: 1000px;
            width: 100%;
        }

        .game-nav {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .game-nav h2 {
            margin: 0;
            font-size: 1.5rem;
        }

        .game-url {
            font-family: monospace;
            background: #f3f4f6;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #d1d5db;
            font-size: 0.8rem;
        }

        .btn {
            padding: 12px 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: background 0.2s ease;
            text-decoration: none;
            display: inline-block;
            text-align: center;
        }

        .btn:hover {
            background: #5a67d8;
        }

        .btn:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
        }

        .btn-back {
            background: #6b7280;
            padding: 8px 16px;
            font-size: 0.9rem;
        }

        .btn-back:hover {
            background: #4b5563;
        }

        .btn-secondary {
            background: #6b7280;
        }

        .btn-secondary:hover {
            background: #4b5563;
        }

        .join-form {
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .form-group input {
            width: 100%;
            padding: 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 1rem;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .player-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #333;
        }

        .game-status {
            font-weight: bold;
            font-size: 1.1rem;
        }

        .board-container {
            margin: 20px 0;
            display: flex;
            justify-content: center;
        }

        .board {
            background: #1e40af;
            border-radius: 10px;
            padding: 10px;
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            min-height: 300px;
        }

        .cell {
            width: 50px;
            height: 50px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid #1e40af;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cell:hover {
            background: #60a5fa;
        }

        .cell.occupied {
            cursor: not-allowed;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }

        .players-list {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .players-list h3 {
            margin-bottom: 10px;
        }

        .player-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            border-bottom: 1px solid #e5e7eb;
        }

        .player-item:last-child {
            border-bottom: none;
        }

        .log {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            max-height: 200px;
            overflow-y: auto;
        }

        .log h3 {
            margin-bottom: 10px;
        }

        .log-entry {
            padding: 5px 0;
            font-size: 0.9rem;
            color: #6b7280;
            border-bottom: 1px solid #e5e7eb;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .winning-line {
            background: #ffd700 !important;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .hidden {
            display: none;
        }

        .error-state {
            text-align: center;
            padding: 60px 20px;
            color: #ef4444;
        }

        .error-state h3 {
            font-size: 1.3rem;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üî¥ Connect4 Multiplayer</h1>
        <p>Real-time collaborative gaming with stateful proxies</p>
    </div>

    <div class="game-container">
        <div class="game-nav">
            <a href="games.html" class="btn btn-back">‚Üê Back to Games</a>
            <h2>Game: <span id="currentGameId"></span></h2>
            <div class="game-url">
                <small>Share this URL: <span id="gameUrl"></span></small>
            </div>
        </div>

        <!-- Error state for invalid game URLs -->
        <div id="errorState" class="error-state hidden">
            <h3>Game not found</h3>
            <p>Please check the URL or create a new game.</p>
            <div style="margin-top: 20px;">
                <a href="games.html" class="btn">Back to Games</a>
            </div>
        </div>

        <!-- Join Form for specific game -->
        <div id="joinGameForm" class="join-form hidden">
            <h3>Join Game</h3>
            <div class="form-group">
                <label for="playerName">Your Name:</label>
                <input type="text" id="playerName" placeholder="Enter your name" required>
            </div>
            <div class="controls">
                <button class="btn" onclick="joinCurrentGame()">Join Game</button>
            </div>
        </div>

        <!-- Game Interface -->
        <div id="gameInterface" class="hidden">
            <div class="game-info">
                <div class="player-info">
                    <span>Current Player:</span>
                    <div id="currentPlayerColor" class="player-color"></div>
                    <span id="currentPlayerName">Waiting...</span>
                </div>
                <div class="game-status" id="gameStatus">Waiting for players...</div>
                <div>Turn: <span id="turnNumber">0</span></div>
            </div>

            <div class="board-container">
                <div id="gameBoard" class="board">
                    <!-- Board cells will be generated by JavaScript -->
                </div>
            </div>

            <div class="controls">
                <button class="btn" onclick="resetGame()">New Game</button>
                <button class="btn btn-secondary" onclick="leaveGame()">Leave Game</button>
            </div>

            <div class="players-list">
                <h3>Players</h3>
                <div id="playersList"></div>
            </div>

            <div class="log">
                <h3>Game Log</h3>
                <div id="gameLog"></div>
            </div>
        </div>
    </div>

    <!-- Load the generated TypeScript client and protobuf types -->
    <script type="module">
        // Import the generated WASM client and protobuf types
        import Connect4_gameClient from './gen/wasm/connect4-game/connect4_gameClient.client.js';
        import { GameState, GameConfig, GameStatus } from './gen/ts/connect4/game_pb.js';
        
        // Make them available globally for the main script
        window.Connect4Client = Connect4_gameClient;
        window.GameState = GameState;
        window.GameConfig = GameConfig;
        window.GameStatus = GameStatus;
    </script>

    <script>
        // =============================================================================
        // STATEFUL PROXY TRANSPORT SYSTEM - Pluggable Architecture
        // =============================================================================
        
        // Abstract base class for transport implementations
        class StatefulTransport {
            constructor(gameId) {
                this.gameId = gameId;
                this.onPatchReceived = null; // Callback for incoming patches
            }
            
            // Send patches to other clients/tabs
            async sendPatches(patches) {
                throw new Error('sendPatches must be implemented by transport');
            }
            
            // Subscribe to incoming patches
            subscribe(callback) {
                this.onPatchReceived = callback;
            }
            
            // Clean up resources
            destroy() {
                // Override in implementations
            }
        }
        
        // BroadcastChannel transport for cross-tab communication
        class BroadcastChannelTransport extends StatefulTransport {
            constructor(gameId) {
                super(gameId);
                this.channel = new BroadcastChannel(`connect4-stateful-${gameId}`);
                this.channel.onmessage = (event) => this.handleMessage(event);
            }
            
            async sendPatches(patches) {
                this.channel.postMessage({
                    type: 'patches',
                    gameId: this.gameId,
                    patches: patches,
                    timestamp: Date.now(),
                    source: 'broadcast'
                });
            }
            
            handleMessage(event) {
                const { type, gameId, patches } = event.data;
                if (type === 'patches' && gameId === this.gameId && this.onPatchReceived) {
                    this.onPatchReceived(patches);
                }
            }
            
            destroy() {
                this.channel.close();
            }
        }
        
        // WebSocket transport for server-based collaboration
        class WebSocketTransport extends StatefulTransport {
            constructor(gameId, wsUrl = null) {
                super(gameId);
                this.wsUrl = wsUrl || `ws://localhost:8080/game/${gameId}`;
                this.ws = null;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.connect();
            }
            
            async connect() {
                try {
                    this.ws = new WebSocket(this.wsUrl);
                    
                    this.ws.onopen = () => {
                        console.log(`WebSocket connected for game ${this.gameId}`);
                        this.reconnectAttempts = 0;
                    };
                    
                    this.ws.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        if (data.type === 'patches' && this.onPatchReceived) {
                            this.onPatchReceived(data.patches);
                        }
                    };
                    
                    this.ws.onclose = () => {
                        this.handleReconnect();
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                    };
                } catch (error) {
                    console.error('Failed to connect WebSocket:', error);
                    this.handleReconnect();
                }
            }
            
            async sendPatches(patches) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'patches',
                        gameId: this.gameId,
                        patches: patches,
                        timestamp: Date.now(),
                        source: 'websocket'
                    }));
                } else {
                    console.warn('WebSocket not ready, patches not sent');
                }
            }
            
            handleReconnect() {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    const delay = Math.pow(2, this.reconnectAttempts) * 1000; // Exponential backoff
                    console.log(`Reconnecting WebSocket in ${delay}ms (attempt ${this.reconnectAttempts})`);
                    setTimeout(() => this.connect(), delay);
                }
            }
            
            destroy() {
                if (this.ws) {
                    this.ws.close();
                }
            }
        }
        
        // Server-Sent Events transport for real-time updates from server
        class SSETransport extends StatefulTransport {
            constructor(gameId, sseUrl = null) {
                super(gameId);
                this.sseUrl = sseUrl || `/events/game/${gameId}`;
                this.eventSource = null;
                this.connect();
            }
            
            connect() {
                this.eventSource = new EventSource(this.sseUrl);
                
                this.eventSource.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (data.type === 'patches' && this.onPatchReceived) {
                        this.onPatchReceived(data.patches);
                    }
                };
                
                this.eventSource.onerror = (error) => {
                    console.error('SSE error:', error);
                };
            }
            
            async sendPatches(patches) {
                // SSE is receive-only, send via regular HTTP POST
                try {
                    await fetch(`/api/game/${this.gameId}/patches`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ patches })
                    });
                } catch (error) {
                    console.error('Failed to send patches via HTTP:', error);
                }
            }
            
            destroy() {
                if (this.eventSource) {
                    this.eventSource.close();
                }
            }
        }
        
        // =============================================================================
        // STATEFUL PROXY - Transport-Agnostic Implementation
        // =============================================================================
        
        class StatefulProxy {
            constructor(gameId, transportType = 'broadcast') {
                this.gameId = gameId;
                this.gameState = null;
                this.patches = [];
                this.lastChangeNumber = 0;
                
                // Initialize pluggable transport
                this.transport = this.createTransport(transportType);
                this.transport.subscribe((patches) => this.handleIncomingPatches(patches));
                
                // Storage keys
                this.storageKey = `connect4_game_${gameId}`;
                this.patchesKey = `connect4_patches_${gameId}`;
                
                // UI update callback
                this.onStateChanged = null;
            }
            
            // Factory method for creating transport instances
            createTransport(type) {
                switch (type) {
                    case 'broadcast':
                        return new BroadcastChannelTransport(this.gameId);
                    case 'websocket':
                        return new WebSocketTransport(this.gameId);
                    case 'sse':
                        return new SSETransport(this.gameId);
                    default:
                        console.warn(`Unknown transport type: ${type}, falling back to broadcast`);
                        return new BroadcastChannelTransport(this.gameId);
                }
            }
            
            // Switch transport at runtime
            async switchTransport(newType) {
                const oldTransport = this.transport;
                this.transport = this.createTransport(newType);
                this.transport.subscribe((patches) => this.handleIncomingPatches(patches));
                
                // Clean up old transport
                oldTransport.destroy();
                
                console.log(`Switched transport from ${oldTransport.constructor.name} to ${this.transport.constructor.name}`);
            }
            
            // Set the game state and initialize proxy
            setGameState(gameState) {
                this.gameState = gameState;
                this.saveState();
                this.notifyStateChanged();
            }
            
            // Apply patches from WASM service calls
            async applyPatchesFromWasm(patches) {
                if (!patches || patches.length === 0) return;
                
                // Apply patches locally
                this.applyPatches(patches);
                
                // Broadcast to other clients
                await this.transport.sendPatches(patches);
                
                // Store patches for conflict resolution
                this.patches.push(...patches);
                this.saveState();
            }
            
            // Handle incoming patches from transport
            handleIncomingPatches(patches) {
                console.log(`Received ${patches.length} patches from transport`);
                this.applyPatches(patches);
                this.saveState();
            }
            
            // Apply patches to local game state
            applyPatches(patches) {
                if (!this.gameState || !patches || patches.length === 0) return;
                
                // Sort patches by change number for correct ordering
                patches.sort((a, b) => (a.changeNumber || 0) - (b.changeNumber || 0));
                
                patches.forEach(patch => {
                    if (patch.changeNumber <= this.lastChangeNumber) {
                        console.log(`Skipping old patch ${patch.changeNumber} (current: ${this.lastChangeNumber})`);
                        return;
                    }
                    
                    this.applyPatch(patch);
                    this.lastChangeNumber = Math.max(this.lastChangeNumber, patch.changeNumber || 0);
                });
                
                this.notifyStateChanged();
            }
            
            // Apply a single patch to the game state
            applyPatch(patch) {
                const fieldPath = patch.fieldPath || patch.field_path;
                const value = this.parseJsonValue(patch.valueJson || patch.value_json);
                
                console.log(`Applying patch: ${patch.operation} ${fieldPath} = ${patch.valueJson || patch.value_json}`);
                
                switch (patch.operation) {
                    case 0: // SET
                        this.setNestedValue(this.gameState, fieldPath, value);
                        break;
                    case 1: // INSERT_LIST
                        this.insertIntoArray(this.gameState, fieldPath, value, patch.index);
                        break;
                    case 2: // REMOVE_LIST
                        this.removeFromArray(this.gameState, fieldPath, patch.index);
                        break;
                    default:
                        console.warn(`Unknown patch operation: ${patch.operation}`);
                }
            }
            
            // Parse JSON value from patch
            parseJsonValue(jsonValue) {
                try {
                    return JSON.parse(jsonValue);
                } catch (e) {
                    return jsonValue;
                }
            }
            
            // Set nested object value by path (e.g., "board.rows[0].cells[1]")
            setNestedValue(obj, path, value) {
                const parts = path.split(/[\.\[\]]+/).filter(Boolean);
                let current = obj;
                
                for (let i = 0; i < parts.length - 1; i++) {
                    const part = parts[i];
                    const nextPart = parts[i + 1];
                    
                    if (!current[part]) {
                        current[part] = isNaN(nextPart) ? {} : [];
                    }
                    current = current[part];
                }
                
                const lastPart = parts[parts.length - 1];
                current[lastPart] = value;
            }
            
            // Insert into array by path
            insertIntoArray(obj, path, value, index = -1) {
                const parts = path.split(/[\.\[\]]+/).filter(Boolean);
                let current = obj;
                
                for (let i = 0; i < parts.length; i++) {
                    if (i === parts.length - 1) {
                        if (!Array.isArray(current[parts[i]])) {
                            current[parts[i]] = [];
                        }
                        if (index >= 0) {
                            current[parts[i]].splice(index, 0, value);
                        } else {
                            current[parts[i]].push(value);
                        }
                    } else {
                        current = current[parts[i]];
                    }
                }
            }
            
            // Remove from array by path
            removeFromArray(obj, path, index) {
                const parts = path.split(/[\.\[\]]+/).filter(Boolean);
                let current = obj;
                
                for (let i = 0; i < parts.length; i++) {
                    if (i === parts.length - 1) {
                        if (Array.isArray(current[parts[i]]) && index >= 0) {
                            current[parts[i]].splice(index, 1);
                        }
                    } else {
                        current = current[parts[i]];
                    }
                }
            }
            
            // Save current state to localStorage
            saveState() {
                if (this.gameState) {
                    localStorage.setItem(this.storageKey, JSON.stringify(this.gameState));
                    localStorage.setItem(this.patchesKey, JSON.stringify(this.patches));
                }
            }
            
            // Load state from localStorage
            loadState() {
                const savedState = localStorage.getItem(this.storageKey);
                const savedPatches = localStorage.getItem(this.patchesKey);
                
                if (savedState) {
                    this.gameState = JSON.parse(savedState);
                }
                if (savedPatches) {
                    this.patches = JSON.parse(savedPatches);
                    this.lastChangeNumber = Math.max(...this.patches.map(p => p.changeNumber || 0), 0);
                }
                
                return this.gameState;
            }
            
            // Set callback for state changes
            onStateChange(callback) {
                this.onStateChanged = callback;
            }
            
            // Notify that state has changed
            notifyStateChanged() {
                if (this.onStateChanged) {
                    this.onStateChanged(this.gameState);
                }
            }
            
            // Clean up resources
            destroy() {
                if (this.transport) {
                    this.transport.destroy();
                }
            }
        }

        // Application state
        let gameState = null;
        let currentPlayerId = null;
        let currentGameId = null;
        let connect4Client = null;
        let statefulProxy = null;

        // UI Elements
        const joinGameForm = document.getElementById('joinGameForm');
        const gameInterface = document.getElementById('gameInterface');
        const errorState = document.getElementById('errorState');
        const gameBoard = document.getElementById('gameBoard');
        const gameStatus = document.getElementById('gameStatus');
        const currentPlayerName = document.getElementById('currentPlayerName');
        const currentPlayerColor = document.getElementById('currentPlayerColor');
        const turnNumber = document.getElementById('turnNumber');
        const playersList = document.getElementById('playersList');
        const gameLog = document.getElementById('gameLog');

        // Initialize WASM client
        async function initializeWasmClient() {
            try {
                addLogEntry('Loading WASM module...');
                connect4Client = new window.Connect4Client();
                await connect4Client.loadWasm('./multiplayer_connect4.wasm');
                await connect4Client.waitUntilReady();
                addLogEntry('WASM module loaded successfully!');
                return true;
            } catch (error) {
                console.error('Failed to load WASM:', error);
                addLogEntry(`Failed to load WASM module: ${error.message}`);
                return false;
            }
        }

        // Get URL parameters
        function getUrlParameter(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }

        // Game state management
        function loadGameState(gameId) {
            const stored = localStorage.getItem(`connect4_game_${gameId}`);
            if (stored) {
                try {
                    return JSON.parse(stored);
                } catch (e) {
                    console.error('Failed to parse stored game state:', e);
                }
            }
            return null;
        }

        function saveGameState(gameId, state) {
            localStorage.setItem(`connect4_game_${gameId}`, JSON.stringify(state));
            // Trigger storage event for other windows
            window.dispatchEvent(new CustomEvent('gameStateChanged', { detail: { gameId, state } }));
        }

        function deleteGameState(gameId) {
            localStorage.removeItem(`connect4_game_${gameId}`);
            window.dispatchEvent(new CustomEvent('gameStateChanged', { detail: { gameId, state: null } }));
        }

        // Listen for game state changes from other windows
        window.addEventListener('gameStateChanged', function(e) {
            const { gameId, state } = e.detail;
            if (gameId === currentGameId) {
                if (!state) {
                    // Game was deleted
                    addLogEntry(`Game "${gameId}" was deleted - all players have left`);
                    setTimeout(() => {
                        window.location.href = 'games.html';
                    }, 2000);
                } else if (gameState) {
                    // Game state updated
                    gameState = state;
                    updateUI();
                    addLogEntry('Game state updated from another window');
                }
            }
        });

        // Also listen for localStorage changes from other windows
        window.addEventListener('storage', function(e) {
            if (e.key === `connect4_game_${currentGameId}`) {
                const newState = e.newValue ? JSON.parse(e.newValue) : null;
                if (!newState) {
                    addLogEntry(`Game "${currentGameId}" was deleted - all players have left`);
                    setTimeout(() => {
                        window.location.href = 'games.html';
                    }, 2000);
                } else if (gameState) {
                    gameState = newState;
                    updateUI();
                    addLogEntry('Game state updated from another window');
                }
            }
        });

        // =============================================================================
        // TRANSPORT SWITCHING AND UTILITY FUNCTIONS
        // =============================================================================
        
        // Switch transport at runtime (useful for testing different approaches)
        async function switchTransport(newType) {
            if (!statefulProxy) {
                addLogEntry('Stateful proxy not initialized');
                return;
            }
            
            const oldType = statefulProxy.transport.constructor.name;
            await statefulProxy.switchTransport(newType);
            addLogEntry(`Switched transport: ${oldType} ‚Üí ${statefulProxy.transport.constructor.name}`);
        }
        
        // Global function to make transport switching available in browser console
        window.switchTransport = switchTransport;
        
        // Update the UI with current game state (enhanced for stateful proxy)
        window.updateGameUI = function(newGameState) {
            if (newGameState) {
                gameState = newGameState;
                updateUI();
                addLogEntry('UI updated from stateful proxy');
            }
        };
        
        // Function to test patch application manually (useful for debugging)
        window.testPatch = function(operation, fieldPath, value) {
            if (!statefulProxy) {
                console.log('Stateful proxy not initialized');
                return;
            }
            
            const patch = {
                operation: operation, // 0=SET, 1=INSERT_LIST, 2=REMOVE_LIST
                fieldPath: fieldPath,
                valueJson: typeof value === 'string' ? value : JSON.stringify(value),
                changeNumber: Date.now(),
                timestamp: Date.now()
            };
            
            statefulProxy.applyPatches([patch]);
            console.log('Applied test patch:', patch);
        };

        // Page initialization with stateful proxy
        async function initializePage() {
            currentGameId = getUrlParameter('gameId');
            const playerId = getUrlParameter('playerId');

            if (!currentGameId) {
                showErrorState();
                return;
            }

            // Initialize stateful proxy with configurable transport
            const transportType = new URLSearchParams(window.location.search).get('transport') || 'broadcast';
            statefulProxy = new StatefulProxy(currentGameId, transportType);
            
            // Set up UI update callback
            statefulProxy.onStateChange((newGameState) => {
                gameState = newGameState;
                updateUI();
            });

            // Initialize WASM client
            const wasmReady = await initializeWasmClient();
            if (!wasmReady) {
                showErrorState();
                return;
            }

            document.getElementById('currentGameId').textContent = currentGameId;
            document.getElementById('gameUrl').textContent = window.location.href.split('?')[0] + '?gameId=' + currentGameId;

            // Try to load existing game state from WASM service
            try {
                const wasmGameState = await connect4Client.connect4Service.getGame({ gameId: currentGameId });
                if (wasmGameState) {
                    statefulProxy.setGameState(wasmGameState);
                    gameState = wasmGameState;
                    
                    // Check if user was already in this game
                    if (playerId && gameState.players.some(p => p.id === playerId)) {
                        currentPlayerId = playerId;
                        showGameInterface();
                        addLogEntry(`Reconnected as ${gameState.players.find(p => p.id === playerId).name}`);
                    } else {
                        showJoinForm();
                    }
                } else {
                    // Try to load from local storage (might have been created by another tab)
                    const localState = statefulProxy.loadState();
                    if (localState) {
                        gameState = localState;
                        showJoinForm();
                        addLogEntry('Loaded game state from local storage');
                    } else {
                        showJoinForm();
                    }
                }
            } catch (error) {
                console.log('Game not found in WASM service:', error);
                
                // Try local storage as fallback
                const localState = statefulProxy.loadState();
                if (localState) {
                    gameState = localState;
                    addLogEntry('Loaded game from local storage');
                }
                showJoinForm();
            }

            addLogEntry(`Initialized with ${transportType} transport. Add ?transport=websocket or ?transport=sse to URL to switch.`);
        }
        }

        function showErrorState() {
            errorState.classList.remove('hidden');
            joinGameForm.classList.add('hidden');
            gameInterface.classList.add('hidden');
        }

        function showJoinForm() {
            joinGameForm.classList.remove('hidden');
            gameInterface.classList.add('hidden');
            errorState.classList.add('hidden');
        }

        function showGameInterface() {
            joinGameForm.classList.add('hidden');
            gameInterface.classList.remove('hidden');
            errorState.classList.add('hidden');
            initializeBoard(gameState.config.boardWidth, gameState.config.boardHeight);
            updateUI();
        }

        // Join current game - now calls WASM service
        async function joinCurrentGame() {
            const playerName = document.getElementById('playerName').value;
            
            if (!playerName) {
                alert('Please enter your name');
                return;
            }

            if (!connect4Client) {
                alert('WASM module not loaded. Please refresh the page.');
                return;
            }

            try {
                addLogEntry(`Joining game "${currentGameId}" as ${playerName}...`);

                // Try to join existing game first
                let response = await connect4Client.connect4Service.joinGame({
                    gameId: currentGameId,
                    playerName: playerName,
                    preferredColor: '' // Let service assign color
                });

                if (response.success) {
                    currentPlayerId = response.playerId;
                    
                    // Set game state through stateful proxy
                    statefulProxy.setGameState(response.gameState);
                    gameState = response.gameState;
                    
                    // Update URL with player ID for reconnection
                    const newUrl = `${window.location.pathname}?gameId=${currentGameId}&playerId=${currentPlayerId}`;
                    window.history.replaceState({}, '', newUrl);
                    
                    showGameInterface();
                    addLogEntry(`Successfully joined game! You are ${playerName} (${response.assignedColor})`);

                    if (gameState.status === 'IN_PROGRESS') {
                        addLogEntry('Game started! Enough players have joined.');
                    }
                } else {
                    // Join failed, try to create the game
                    addLogEntry('Game not found, creating new game...');
                    await createNewGameAndJoin(currentGameId, playerName);
                }

            } catch (error) {
                console.error('Error joining game:', error);
                addLogEntry(`Failed to join game: ${error.message}`);
                
                // Fallback: try to create new game
                try {
                    await createNewGameAndJoin(currentGameId, playerName);
                } catch (createError) {
                    console.error('Error creating game:', createError);
                    addLogEntry(`Failed to create game: ${createError.message}`);
                    alert('Failed to join or create game. Please try again.');
                }
            }
        }

        async function createNewGameAndJoin(gameId, playerName) {
            try {
                addLogEntry(`Creating new game "${gameId}"...`);

                const response = await connect4Client.connect4Service.createGame({
                    gameId: gameId,
                    config: {
                        boardWidth: 7,
                        boardHeight: 6,
                        minPlayers: 2,
                        maxPlayers: 4,
                        connectLength: 4,
                        allowMultipleWinners: false,
                        moveTimeoutSeconds: 30
                    },
                    creatorName: playerName
                });

                if (response.success) {
                    currentPlayerId = response.playerId;
                    gameState = response.gameState;
                    
                    // Update URL with player ID
                    const newUrl = `${window.location.pathname}?gameId=${gameId}&playerId=${currentPlayerId}`;
                    window.history.replaceState({}, '', newUrl);
                    
                    // Save to localStorage for cross-tab sync
                    saveGameStateToLocalStorage(gameId, gameState);
                    
                    showGameInterface();
                    addLogEntry(`Game "${gameId}" created successfully! You are the first player.`);
                    addLogEntry('Waiting for more players to start...');
                } else {
                    throw new Error(response.errorMessage || 'Failed to create game');
                }
            } catch (error) {
                console.error('Error creating game:', error);
                throw error;
            }
        }

        // Initialize the board
        function initializeBoard(width = 7, height = 6) {
            gameBoard.innerHTML = '';
            gameBoard.style.gridTemplateColumns = `repeat(${width}, 1fr)`;
            
            for (let row = 0; row < height; row++) {
                for (let col = 0; col < width; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.onclick = () => dropPiece(col);
                    gameBoard.appendChild(cell);
                }
            }
        }

        // Update the UI with current game state
        function updateUI() {
            if (!gameState) return;

            // Update game status
            gameStatus.textContent = getStatusText(gameState.status);
            turnNumber.textContent = gameState.turnNumber;

            // Update current player info
            if (gameState.currentPlayerId) {
                const currentPlayer = gameState.players.find(p => p.id === gameState.currentPlayerId);
                if (currentPlayer) {
                    currentPlayerName.textContent = currentPlayer.name;
                    currentPlayerColor.style.backgroundColor = currentPlayer.color;
                }
            }

            // Update board
            updateBoard();

            // Update players list
            updatePlayersList();
        }

        // Update the board display
        function updateBoard() {
            const cells = gameBoard.querySelectorAll('.cell');
            
            cells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const playerId = gameState.board.rows[row].cells[col];
                
                if (playerId) {
                    const player = gameState.players.find(p => p.id === playerId);
                    if (player) {
                        cell.style.backgroundColor = player.color;
                        cell.classList.add('occupied');
                    }
                } else {
                    cell.style.backgroundColor = '#3b82f6';
                    cell.classList.remove('occupied');
                }
            });
        }

        // Update players list
        function updatePlayersList() {
            playersList.innerHTML = '';
            
            gameState.players.forEach(player => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player-item';
                
                const colorDiv = document.createElement('div');
                colorDiv.className = 'player-color';
                colorDiv.style.backgroundColor = player.color;
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = player.name;
                if (player.id === currentPlayerId) {
                    nameSpan.textContent += ' (You)';
                }
                
                const statusSpan = document.createElement('span');
                statusSpan.textContent = player.isConnected ? ' ‚Ä¢ Online' : ' ‚Ä¢ Offline';
                statusSpan.style.color = player.isConnected ? '#10b981' : '#ef4444';
                
                playerDiv.appendChild(colorDiv);
                playerDiv.appendChild(nameSpan);
                playerDiv.appendChild(statusSpan);
                playersList.appendChild(playerDiv);
            });
        }

        // Drop a piece in the specified column - now uses WASM service with stateful proxy
        async function dropPiece(column) {
            if (!gameState || gameState.status !== 'IN_PROGRESS') {
                addLogEntry('Game is not in progress');
                return;
            }

            if (gameState.currentPlayerId !== currentPlayerId) {
                addLogEntry('It\'s not your turn');
                return;
            }

            if (gameState.board.columnHeights[column] >= gameState.config.boardHeight) {
                addLogEntry('Column is full');
                return;
            }

            try {
                // Call WASM service to drop piece
                const response = await connect4Client.connect4Service.dropPiece({
                    gameId: currentGameId,
                    playerId: currentPlayerId,
                    column: column
                });

                if (response.success && response.patches) {
                    // Apply patches through stateful proxy (will broadcast to other tabs)
                    await statefulProxy.applyPatchesFromWasm(response.patches);
                    
                    const player = gameState.players.find(p => p.id === currentPlayerId);
                    addLogEntry(`${player.name} dropped piece in column ${column + 1}`);
                    
                    // Check if game finished
                    if (response.result && response.result.formedLine) {
                        addLogEntry(`üéâ ${player.name} wins with ${response.result.winningLines.length} winning line(s)!`);
                        highlightWinningLines(response.result.winningLines);
                    }
                } else {
                    addLogEntry(`Failed to drop piece: ${response.errorMessage || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Error dropping piece:', error);
                addLogEntry(`Error: ${error.message}`);
            }
        }

        // Check for winning lines (simplified version)
        function checkForWinningLines(row, col, playerId) {
            const lines = [];
            const directions = [
                { dx: 1, dy: 0, name: 'horizontal' },
                { dx: 0, dy: 1, name: 'vertical' },
                { dx: 1, dy: 1, name: 'diagonal_down' },
                { dx: 1, dy: -1, name: 'diagonal_up' }
            ];

            directions.forEach(dir => {
                const positions = [];
                
                // Check both directions from the placed piece
                for (let direction = -1; direction <= 1; direction += 2) {
                    let r = row;
                    let c = col;
                    
                    while (r >= 0 && r < gameState.config.boardHeight && 
                           c >= 0 && c < gameState.config.boardWidth &&
                           gameState.board.rows[r].cells[c] === playerId) {
                        positions.push({ row: r, column: c });
                        r += direction * dir.dy;
                        c += direction * dir.dx;
                    }
                }

                if (positions.length >= gameState.config.connectLength) {
                    lines.push({ positions, direction: dir.name });
                }
            });

            return lines;
        }

        // Highlight winning lines on the board
        function highlightWinningLines(lines) {
            lines.forEach(line => {
                line.positions.forEach(pos => {
                    const cell = document.querySelector(`[data-row="${pos.row}"][data-col="${pos.column}"]`);
                    if (cell) {
                        cell.classList.add('winning-line');
                    }
                });
            });
        }

        // Utility functions
        function getStatusText(status) {
            switch (status) {
                case 'WAITING_FOR_PLAYERS': return 'Waiting for players...';
                case 'IN_PROGRESS': return 'Game in progress';
                case 'FINISHED': return 'Game finished';
                default: return 'Unknown status';
            }
        }

        function addLogEntry(message) {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            gameLog.appendChild(entry);
            gameLog.scrollTop = gameLog.scrollHeight;
        }

        // Game management functions
        function resetGame() {
            if (confirm('Are you sure you want to start a new game?')) {
                if (gameState) {
                    gameState.board.rows.forEach(row => row.cells.fill(''));
                    gameState.board.columnHeights.fill(0);
                    gameState.status = 'IN_PROGRESS';
                    gameState.turnNumber = 0;
                    gameState.winners = [];
                    gameState.currentPlayerId = gameState.players[0].id;
                    
                    saveGameState(currentGameId, gameState);
                    updateUI();
                    addLogEntry('New game started!');
                    
                    // Remove winning line highlights
                    document.querySelectorAll('.winning-line').forEach(cell => {
                        cell.classList.remove('winning-line');
                    });
                }
            }
        }

        function leaveGame() {
            if (confirm('Are you sure you want to leave the game?')) {
                // Remove current player from game state
                if (gameState && currentPlayerId) {
                    gameState.players = gameState.players.filter(p => p.id !== currentPlayerId);
                    
                    // If no players left, delete the game entirely
                    if (gameState.players.length === 0) {
                        deleteGameState(currentGameId);
                        addLogEntry(`Game "${currentGameId}" deleted - all players have left`);
                    } else {
                        // Still have players, just save the updated state
                        saveGameState(currentGameId, gameState);
                        addLogEntry(`You left the game. ${gameState.players.length} player(s) remaining.`);
                    }
                }
                
                // Navigate back to games list
                window.location.href = 'games.html';
            }
        }

        // Initialize the page
        initializePage();
        
        // Auto-refresh game state every 2 seconds for real-time updates
        setInterval(() => {
            if (currentGameId && gameState) {
                const latestState = loadGameState(currentGameId);
                if (latestState && JSON.stringify(latestState) !== JSON.stringify(gameState)) {
                    gameState = latestState;
                    updateUI();
                }
            }
        }, 2000);
    </script>
</body>
</html>
