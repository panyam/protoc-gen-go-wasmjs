// Generated stateful proxy for Connect4Service
// DO NOT EDIT - This file is automatically generated

import { Connect4Service } from '../connect4service';
import { 
  MessagePatch, 
  PatchBatch, 
  PatchOperation,
  ConflictResolution 
} from './patches';




/**
 * Stateful proxy for Connect4Service service
 * Maintains local state and applies differential patches for real-time collaboration
 */
export class StatefulConnect4ServiceProxy {
  private localState: connect4.GameState | null = null;
  private subscribers: Set<(state: connect4.GameState) => void> = new Set();
  private lastAppliedChangeNumber: number = 0;
  private conflictResolution: ConflictResolution = ConflictResolution.CHANGE_NUMBER_BASED;

  constructor(
    private service: Connect4Service,
    private entityId: string
  ) {}

  /**
   * Get the current local state
   */
  getState(): connect4.GameState | null {
    return this.localState;
  }

  /**
   * Initialize the proxy with initial state
   */
  async initialize(initialState?: connect4.GameState): Promise<void> {
    if (initialState) {
      this.localState = initialState;
    } else {
      // Load initial state from service
      // TODO: Generate based on service methods
      console.warn('Auto-loading initial state not yet implemented');
    }
    this.notifySubscribers();
  }

  /**
   * Apply patches from external sources (transport, other users, etc.)
   * Returns true if patches were applied, false if ignored (due to ordering)
   */
  applyPatches(patches: MessagePatch[], changeNumber: number): boolean {
    // Implement ordering/conflict resolution
    if (changeNumber <= this.lastAppliedChangeNumber) {
      console.log(`Ignoring old change ${changeNumber}, last applied: ${this.lastAppliedChangeNumber}`);
      return false; // Ignore old changes
    }

    this.internalApplyPatches(patches);
    this.lastAppliedChangeNumber = changeNumber;
    this.notifySubscribers();
    return true;
  }

  /**
   * Apply a complete patch batch
   */
  applyPatchBatch(batch: PatchBatch): boolean {
    if (batch.messageType !== 'connect4.GameState') {
      console.warn(`Patch batch is for ${batch.messageType}, but proxy handles connect4.GameState`);
      return false;
    }

    if (batch.entityId !== this.entityId) {
      console.warn(`Patch batch is for entity ${batch.entityId}, but proxy handles ${this.entityId}`);
      return false;
    }

    return this.applyPatches(batch.patches, batch.changeNumber);
  }

  /**
   * Subscribe to state changes
   */
  subscribe(callback: (state: connect4.GameState) => void): () => void {
    this.subscribers.add(callback);
    
    // Immediately call with current state if available
    if (this.localState) {
      callback(this.localState);
    }
    
    return () => this.subscribers.delete(callback);
  }

  /**
   * Get the last applied change number
   */
  getLastChangeNumber(): number {
    return this.lastAppliedChangeNumber;
  }

  /**
   * Reset the proxy state
   */
  reset(): void {
    this.localState = null;
    this.lastAppliedChangeNumber = 0;
    this.subscribers.clear();
  }

  // ========================================
  // Generated Methods for Stateful Service
  // ========================================
  /**
   * DropPiece - Returns patches instead of full state
   */
  async dropPieceAndApply(request: DropPieceRequest): Promise<boolean> {
    try {
      const response = await this.service.dropPiece(request);
      
      // TODO: Convert response to PatchBatch and apply
      console.warn('Patch conversion not yet implemented');
      return false;
    } catch (error) {
      console.error(`Error in DropPiece:`, error);
      return false;
    }
  }

  // ========================================
  // Private Methods
  // ========================================

  /**
   * Apply patches in the exact order provided by backend
   */
  private internalApplyPatches(patches: MessagePatch[]): void {
    if (!this.localState) return;

    // Apply patches in the exact order provided by backend
    for (const patch of patches) {
      try {
        this.applySinglePatch(this.localState, patch);
      } catch (error) {
        console.error(`Failed to apply patch:`, patch, error);
        // Could implement rollback strategy here
      }
    }
  }

  /**
   * Apply a single patch operation
   */
  private applySinglePatch(target: any, patch: MessagePatch): void {
    const pathSegments = this.parseFieldPath(patch.fieldPath);
    const { parent, fieldName } = this.resolveParentAndField(target, pathSegments);

    switch (patch.operation) {
      case PatchOperation.SET:
        parent[fieldName] = patch.value;
        break;

      case PatchOperation.INSERT_LIST:
        if (!Array.isArray(parent[fieldName])) {
          parent[fieldName] = [];
        }
        parent[fieldName].splice(patch.index!, 0, patch.value);
        break;

      case PatchOperation.REMOVE_LIST:
        if (Array.isArray(parent[fieldName])) {
          parent[fieldName].splice(patch.index!, 1);
        }
        break;

      case PatchOperation.MOVE_LIST:
        if (Array.isArray(parent[fieldName])) {
          const item = parent[fieldName].splice(patch.oldIndex!, 1)[0];
          parent[fieldName].splice(patch.index!, 0, item);
        }
        break;

      case PatchOperation.INSERT_MAP:
        if (typeof parent[fieldName] !== 'object') {
          parent[fieldName] = {};
        }
        parent[fieldName][patch.key!] = patch.value;
        break;

      case PatchOperation.REMOVE_MAP:
        if (typeof parent[fieldName] === 'object') {
          delete parent[fieldName][patch.key!];
        }
        break;

      case PatchOperation.CLEAR_LIST:
        if (Array.isArray(parent[fieldName])) {
          parent[fieldName].length = 0;
        }
        break;

      case PatchOperation.CLEAR_MAP:
        if (typeof parent[fieldName] === 'object') {
          for (const key in parent[fieldName]) {
            delete parent[fieldName][key];
          }
        }
        break;

      default:
        throw new Error(`Unknown patch operation: ${patch.operation}`);
    }
  }

  /**
   * Parse field path into segments
   */
  private parseFieldPath(fieldPath: string): string[] {
    // Handle complex paths like "players[2].name" or "places['tile_123'].latitude"
    return fieldPath
      .replace(/\[(\d+)\]/g, '.$1')           // Convert array indices: players[2] -> players.2
      .replace(/\['([^']+)'\]/g, '.$1')       // Convert map keys: places['key'] -> places.key
      .replace(/\["([^"]+)"\]/g, '.$1')       // Convert map keys: places["key"] -> places.key
      .split('.')
      .filter(segment => segment.length > 0);
  }

  /**
   * Resolve parent object and field name from path
   */
  private resolveParentAndField(target: any, pathSegments: string[]): { parent: any; fieldName: string } {
    let current = target;

    // Navigate to parent object
    for (let i = 0; i < pathSegments.length - 1; i++) {
      const segment = pathSegments[i];

      if (current[segment] === undefined) {
        // Auto-create intermediate objects/arrays as needed
        const nextSegment = pathSegments[i + 1];
        current[segment] = this.isNumeric(nextSegment) ? [] : {};
      }

      current = current[segment];
    }

    return {
      parent: current,
      fieldName: pathSegments[pathSegments.length - 1]
    };
  }

  /**
   * Check if string is numeric
   */
  private isNumeric(str: string): boolean {
    return /^\d+$/.test(str);
  }

  /**
   * Notify all subscribers of state changes
   */
  private notifySubscribers(): void {
    if (this.localState) {
      this.subscribers.forEach(callback => callback(this.localState!));
    }
  }
}
