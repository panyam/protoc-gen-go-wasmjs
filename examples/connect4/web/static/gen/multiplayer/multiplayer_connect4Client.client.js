// Code generated by protoc-gen-go-wasmjs. DO NOT EDIT.
// source: connect4/game.proto
/**
 * Error class for WASM-specific errors
 */
export class WasmError extends Error {
    constructor(message, methodPath) {
        super(message);
        this.methodPath = methodPath;
        this.name = 'WasmError';
    }
}
/**
 * multiplayer_connect4 WASM client
 * Provides a clean interface between UI components and the Go WASM service implementations
 */
export class Multiplayer_connect4Client {
    constructor() {
        this.wasmLoadPromise = null;
        this.connect4Service = new Connect4ServiceClientImpl(this);
    }
    /**
     * Load the WASM module asynchronously
     */
    async loadWasm(wasmPath = './multiplayer_connect4.wasm') {
        if (this.wasmLoadPromise) {
            return this.wasmLoadPromise;
        }
        this.wasmLoadPromise = this.loadWASMModule(wasmPath);
        return this.wasmLoadPromise;
    }
    /**
     * Check if WASM is ready for operations
     */
    isReady() {
        return this.wasm !== null && this.wasm !== undefined;
    }
    /**
     * Wait for WASM to be ready (use during initialization)
     */
    async waitUntilReady() {
        if (!this.wasmLoadPromise) {
            throw new Error('WASM loading not started. Call loadWasm() first.');
        }
        await this.wasmLoadPromise;
    }
    /**
     * Internal method to call WASM functions with JSON conversion
     */
    callMethod(methodPath, request) {
        this.ensureWASMLoaded();
        try {
            // Convert request to JSON
            const jsonReq = JSON.parse(JSON.stringify(request));
            const wasmMethod = this.getWasmMethod(methodPath);
            const wasmResponse = wasmMethod(JSON.stringify(jsonReq));
            if (!wasmResponse.success) {
                throw new WasmError(wasmResponse.message, methodPath);
            }
            // Return response data directly
            return wasmResponse.data;
        }
        catch (error) {
            if (error instanceof WasmError) {
                throw error;
            }
            throw new WasmError(`Call error: ${error instanceof Error ? error.message : String(error)}`, methodPath);
        }
    }
    /**
     * Load the WASM module implementation
     */
    async loadWASMModule(wasmPath) {
        console.log('Loading multiplayer_connect4 WASM module...');
        // Check if WASM is already loaded (for testing environments)
        if (window.multiplayerConnect4) {
            console.log('WASM module already loaded (pre-loaded in test environment)');
            this.wasm = window.multiplayerConnect4;
            return;
        }
        // Load Go's WASM support
        if (!window.Go) {
            const script = document.createElement('script');
            script.src = '/static/wasm/wasm_exec.js';
            document.head.appendChild(script);
            await new Promise((resolve, reject) => {
                script.onload = () => resolve();
                script.onerror = () => reject(new Error('Failed to load wasm_exec.js'));
            });
        }
        // Initialize Go WASM runtime
        const go = new window.Go();
        const wasmModule = await WebAssembly.instantiateStreaming(fetch(wasmPath), go.importObject);
        // Run the WASM module
        go.run(wasmModule.instance);
        // Verify WASM APIs are available
        if (!window.multiplayerConnect4) {
            throw new Error('WASM APIs not found - module may not have loaded correctly');
        }
        this.wasm = window.multiplayerConnect4;
        console.log('multiplayer_connect4 WASM module loaded successfully');
    }
    /**
     * Ensure WASM module is loaded (synchronous version for service calls)
     */
    ensureWASMLoaded() {
        if (!this.isReady()) {
            throw new Error('WASM module not loaded. Call loadWasm() and waitUntilReady() first.');
        }
    }
    /**
     * Get WASM method function by path
     */
    getWasmMethod(methodPath) {
        // Handle namespaced structure: namespace.service.method
        const parts = methodPath.split('.');
        let current = this.wasm;
        for (const part of parts) {
            current = current[part];
            if (!current) {
                throw new Error(`Method not found: ${methodPath}`);
            }
        }
        return current;
    }
}
/**
 * Connect4Service service client implementation
 */
class Connect4ServiceClientImpl {
    constructor(parent) {
        this.parent = parent;
    }
    async getGame(request) {
        return this.parent.callMethod('connect4Service.getGame', request);
    }
    async dropPiece(request) {
        return this.parent.callMethod('connect4Service.dropPiece', request);
    }
    async joinGame(request) {
        return this.parent.callMethod('connect4Service.joinGame', request);
    }
    async createGame(request) {
        return this.parent.callMethod('connect4Service.createGame', request);
    }
}
// Export the main client class
export default Multiplayer_connect4Client;
