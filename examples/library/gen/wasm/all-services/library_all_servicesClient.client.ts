// Code generated by protoc-gen-go-wasmjs. DO NOT EDIT.
// source: library/v2/analytics.proto

import { BrowserServiceManager } from './browserServiceManager.js';

/**
 * WASM Response interface for all service calls
 */
export interface WASMResponse<T = any> {
    success: boolean;
    message: string;
    data: T;
}

/**
 * Error class for WASM-specific errors
 */
export class WasmError extends Error {
    constructor(message: string, public readonly methodPath?: string) {
        super(message);
        this.name = 'WasmError';
    }
}
/**
 * AnalyticsService service client interface
 * Uses any types since we generate our own TypeScript interfaces
 */
export interface AnalyticsServiceMethods {
	getBookAnalytics(request: any): Promise<any>;
}
/**
 * LibraryService service client interface
 * Uses any types since we generate our own TypeScript interfaces
 */
export interface LibraryServiceMethods {
	searchBooksV2(request: any): Promise<any>;
}

/**
 * library_all_services WASM client
 * Provides a clean interface between UI components and the Go WASM service implementations
 */
export class Library_all_servicesClient {
    private wasm: any;
    private wasmLoadPromise: Promise<void> | null = null;
    private browserServiceManager: BrowserServiceManager | null = null;

    // Service-specific clients
    public readonly analyticsService: AnalyticsServiceClientImpl;
    public readonly libraryService: LibraryServiceClientImpl;

    constructor() {
        this.analyticsService = new AnalyticsServiceClientImpl(this);
        this.libraryService = new LibraryServiceClientImpl(this);
        this.browserServiceManager = new BrowserServiceManager();
    }

    /**
     * Register a browser service implementation
     * Can be used to register browser services from any package
     */
    public registerBrowserService(name: string, implementation: any): void {
        if (!this.browserServiceManager) {
            throw new Error('Browser service manager not initialized');
        }
        this.browserServiceManager.registerService(name, implementation);
    }

    /**
     * Load the WASM module asynchronously
     */
    public async loadWasm(wasmPath: string = './library_all_services.wasm'): Promise<void> {
        if (this.wasmLoadPromise) {
            return this.wasmLoadPromise;
        }

        this.wasmLoadPromise = this.loadWASMModule(wasmPath);
        return this.wasmLoadPromise;
    }

    /**
     * Check if WASM is ready for operations
     */
    public isReady(): boolean {
        return this.wasm !== null && this.wasm !== undefined;
    }

    /**
     * Wait for WASM to be ready (use during initialization)
     */
    public async waitUntilReady(): Promise<void> {
        if (!this.wasmLoadPromise) {
            throw new Error('WASM loading not started. Call loadWasm() first.');
        }
        await this.wasmLoadPromise;
    }

    /**
     * Internal method to call WASM functions with JSON conversion
     */
    public callMethod<TRequest, TResponse>(
        methodPath: string,
        request: TRequest
    ): Promise<TResponse> {
        this.ensureWASMLoaded();

        try {
            // Convert request to JSON
            const jsonReq = JSON.parse(JSON.stringify(request));
            const wasmMethod = this.getWasmMethod(methodPath);
            const wasmResponse = wasmMethod(JSON.stringify(jsonReq));

            if (!wasmResponse.success) {
                throw new WasmError(wasmResponse.message, methodPath);
            }

            // Return response data directly
            return wasmResponse.data;
        } catch (error) {
            if (error instanceof WasmError) {
                throw error;
            }
            throw new WasmError(
                `Call error: ${error instanceof Error ? error.message : String(error)}`,
                methodPath
            );
        }
    }

    /**
     * Internal method to call async WASM functions with callback
     */
    public callMethodWithCallback<TRequest>(
        methodPath: string,
        request: TRequest,
        callback: (response: any, error?: string) => void
    ): Promise<void> {
        this.ensureWASMLoaded();

        try {
            // Convert request to JSON
            const jsonReq = JSON.parse(JSON.stringify(request));
            const wasmMethod = this.getWasmMethod(methodPath);
            
            // Call WASM method with callback function
            const wasmResponse = wasmMethod(JSON.stringify(jsonReq), callback);

            if (!wasmResponse.success) {
                throw new WasmError(wasmResponse.message, methodPath);
            }

            // Async methods return immediately
            return Promise.resolve();
        } catch (error) {
            if (error instanceof WasmError) {
                throw error;
            }
            throw new WasmError(
                `Call error: ${error instanceof Error ? error.message : String(error)}`,
                methodPath
            );
        }
    }

    /**
     * Internal method to call server streaming WASM functions
     */
    public callStreamingMethod<TRequest, TResponse>(
        methodPath: string,
        request: TRequest,
        callback: (response: TResponse | null, error: string | null, done: boolean) => boolean
    ): void {
        this.ensureWASMLoaded();

        try {
            // Convert request to JSON
            const jsonReq = JSON.parse(JSON.stringify(request));
            const wasmMethod = this.getWasmMethod(methodPath);

            // Wrap the callback to parse JSON responses
            const wrappedCallback = (responseStr: string | null, error: string | null, done: boolean): boolean => {
                let response: TResponse | null = null;
                if (responseStr && !error) {
                    try {
                        response = JSON.parse(responseStr);
                    } catch (e) {
                        // If parsing fails, pass the raw string
                        response = responseStr as any;
                    }
                }
                return callback(response, error, done);
            };

            // Call WASM streaming method with wrapped callback
            const wasmResponse = wasmMethod(JSON.stringify(jsonReq), wrappedCallback);

            if (!wasmResponse.success) {
                throw new WasmError(wasmResponse.message, methodPath);
            }

            // Streaming methods return immediately
        } catch (error) {
            if (error instanceof WasmError) {
                throw error;
            }
            throw new WasmError(
                `Streaming call error: ${error instanceof Error ? error.message : String(error)}`,
                methodPath
            );
        }
    }

    /**
     * Load the WASM module implementation
     */
    private async loadWASMModule(wasmPath: string): Promise<void> {
        console.log('Loading library_all_services WASM module...');

        // Check if WASM is already loaded (for testing environments)
        if ((window as any).library) {
            console.log('WASM module already loaded (pre-loaded in test environment)');
            this.wasm = (window as any).library;
            return;
        }

        // Load Go's WASM support
        if (!(window as any).Go) {
            const script = document.createElement('script');
            script.src = '/static/wasm/wasm_exec.js';
            document.head.appendChild(script);

            await new Promise<void>((resolve, reject) => {
                script.onload = () => resolve();
                script.onerror = () => reject(new Error('Failed to load wasm_exec.js'));
            });
        }

        // Initialize Go WASM runtime
        const go = new (window as any).Go();
        const wasmModule = await WebAssembly.instantiateStreaming(
            fetch(wasmPath),
            go.importObject
        );

        // Run the WASM module
        go.run(wasmModule.instance);

        // Start browser service manager (always available for cross-package browser services)
        if (this.browserServiceManager) {
            this.browserServiceManager.setWasmModule(window);
            this.browserServiceManager.startProcessing();
        }

        // Verify WASM APIs are available
        if (!(window as any).library) {
            throw new Error('WASM APIs not found - module may not have loaded correctly');
        }
        this.wasm = (window as any).library;

        console.log('library_all_services WASM module loaded successfully');
    }

    /**
     * Ensure WASM module is loaded (synchronous version for service calls)
     */
    private ensureWASMLoaded(): void {
        if (!this.isReady()) {
            throw new Error('WASM module not loaded. Call loadWasm() and waitUntilReady() first.');
        }
    }

    /**
     * Get WASM method function by path
     */
    private getWasmMethod(methodPath: string): Function {
        // Handle namespaced structure: namespace.service.method
        const parts = methodPath.split('.');
        let current = this.wasm;
        for (const part of parts) {
            current = current[part];
            if (!current) {
                throw new Error(`Method not found: ${methodPath}`);
            }
        }
        return current;
    }
}
/**
 * AnalyticsService service client implementation
 */
class AnalyticsServiceClientImpl implements AnalyticsServiceMethods {
    constructor(private parent: Library_all_servicesClient) {}
    async getBookAnalytics(request: any): Promise<any> {
        return this.parent.callMethod('analyticsService.getBookAnalytics', request);
    }
}
/**
 * LibraryService service client implementation
 */
class LibraryServiceClientImpl implements LibraryServiceMethods {
    constructor(private parent: Library_all_servicesClient) {}
    async searchBooksV2(request: any): Promise<any> {
        return this.parent.callMethod('libraryService.searchBooksV2', request);
    }
}

// Re-export BrowserServiceManager for cross-package use
export { BrowserServiceManager };

// Export the main client class as default
export default Library_all_servicesClient;