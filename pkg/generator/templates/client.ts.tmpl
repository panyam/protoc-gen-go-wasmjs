// Code generated by protoc-gen-go-wasmjs. DO NOT EDIT.
// source: {{ .SourcePath }}

{{- range .TSImports }}
import {
	{{- $first := true }}
	{{- range .Types }}
		{{- if not $first }}, {{ end }}
		{{ . }}
		{{- $first = false }}
	{{- end }}
} from '{{ .ImportPath }}';
{{- end }}

/**
 * WASM Response interface for all service calls
 */
export interface WASMResponse<T = any> {
    success: boolean;
    message: string;
    data: T;
}

/**
 * Error class for WASM-specific errors
 */
export class WasmError extends Error {
    constructor(message: string, public readonly methodPath?: string) {
        super(message);
        this.name = 'WasmError';
    }
}

/**
 * Conversion options for proto to JSON transformation
 */
export interface ConversionOptions {
    /**
     * Custom handling for oneof fields
     * If true, attempts to flatten oneof objects for Go compatibility
     */
    handleOneofs?: boolean;
    
    /**
     * Custom field name transformer
     * Can be used to convert between camelCase and snake_case
     */
    fieldTransformer?: (fieldName: string) => string;
    
    /**
     * Whether to emit default values for fields
     */
    emitDefaults?: boolean;
    
    /**
     * Custom BigInt serialization
     */
    bigIntHandler?: (value: bigint) => string | number;
}

{{- range .Services }}
/**
 * {{ .Name }} service client interface
 */
export interface {{ .Name }}Methods {
	{{- range .Methods }}
		{{- if .ShouldGenerate }}
	{{ .JSName }}(request: {{ .RequestTSType }}): Promise<{{ .ResponseTSType }}>;
		{{- end }}
	{{- end }}
}
{{- end }}

/**
 * {{ .ModuleName }} WASM client
 * Provides a clean interface between UI components and the Go WASM service implementations
 */
export class {{ .ModuleName | title }}Client {
    private wasm: any;
    private wasmLoadPromise: Promise<void> | null = null;
    private conversionOptions: ConversionOptions = {
        handleOneofs: true,
        emitDefaults: false,
        bigIntHandler: (value: bigint) => value.toString()
    };

    // Service-specific clients
{{- range .Services }}
    public readonly {{ .JSName }}: {{ .Name }}ClientImpl;
{{- end }}

    constructor(options?: Partial<ConversionOptions>) {
        if (options) {
            this.conversionOptions = { ...this.conversionOptions, ...options };
        }
{{- range .Services }}
        this.{{ .JSName }} = new {{ .Name }}ClientImpl(this);
{{- end }}
    }

    /**
     * Load the WASM module asynchronously
     */
    public async loadWasm(wasmPath: string = './{{ .ModuleName }}.wasm'): Promise<void> {
        if (this.wasmLoadPromise) {
            return this.wasmLoadPromise;
        }

        this.wasmLoadPromise = this.loadWASMModule(wasmPath);
        return this.wasmLoadPromise;
    }

    /**
     * Check if WASM is ready for operations
     */
    public isReady(): boolean {
        return this.wasm !== null && this.wasm !== undefined;
    }

    /**
     * Wait for WASM to be ready (use during initialization)
     */
    public async waitUntilReady(): Promise<void> {
        if (!this.wasmLoadPromise) {
            throw new Error('WASM loading not started. Call loadWasm() first.');
        }
        await this.wasmLoadPromise;
    }

    /**
     * Configure conversion options at runtime
     */
    public setConversionOptions(options: Partial<ConversionOptions>): void {
        this.conversionOptions = { ...this.conversionOptions, ...options };
    }

    /**
     * Internal method to call WASM functions with type conversion
     */
    public callMethod<TRequest, TResponse>(
        methodPath: string,
        request: TRequest
    ): Promise<TResponse> {
        this.ensureWASMLoaded();

        try {
            // Convert request to JSON with custom handling
            const jsonReq = this.convertToJson(request);
            const wasmMethod = this.getWasmMethod(methodPath);
            const wasmResponse = wasmMethod(JSON.stringify(jsonReq));

            if (!wasmResponse.success) {
                throw new WasmError(wasmResponse.message, methodPath);
            }

            // Convert response from JSON with custom handling
            return this.convertFromJson(wasmResponse.data, (request as any).constructor);
        } catch (error) {
            if (error instanceof WasmError) {
                throw error;
            }
            throw new WasmError(
                `Proto conversion error: ${error instanceof Error ? error.message : String(error)}`,
                methodPath
            );
        }
    }

    /**
     * Load the WASM module implementation
     */
    private async loadWASMModule(wasmPath: string): Promise<void> {
        console.log('Loading {{ .ModuleName }} WASM module...');

        // Check if WASM is already loaded (for testing environments) 
{{- if eq .APIStructure "namespaced" }}
        if ((window as any).{{ .JSNamespace }}) {
            console.log('WASM module already loaded (pre-loaded in test environment)');
            this.wasm = (window as any).{{ .JSNamespace }};
            return;
        }
{{- else if eq .APIStructure "flat" }}
        // Check for any flat function to determine if loaded
        {{- $firstService := index .Services 0 }}
        {{- $firstMethod := index $firstService.Methods 0 }}
        if ((window as any).{{ .JSNamespace }}{{ $firstMethod.Name }}) {
            console.log('WASM module already loaded (pre-loaded in test environment)');
            this.wasm = window as any;
            return;
        }
{{- else if eq .APIStructure "service_based" }}
        if ((window as any).services) {
            console.log('WASM module already loaded (pre-loaded in test environment)');
            this.wasm = (window as any).services;
            return;
        }
{{- end }}

        // Load Go's WASM support
        if (!(window as any).Go) {
            const script = document.createElement('script');
            script.src = '/static/wasm/wasm_exec.js';
            document.head.appendChild(script);

            await new Promise<void>((resolve, reject) => {
                script.onload = () => resolve();
                script.onerror = () => reject(new Error('Failed to load wasm_exec.js'));
            });
        }

        // Initialize Go WASM runtime
        const go = new (window as any).Go();
        const wasmModule = await WebAssembly.instantiateStreaming(
            fetch(wasmPath),
            go.importObject
        );

        // Run the WASM module
        go.run(wasmModule.instance);

        // Verify WASM APIs are available
{{- if eq .APIStructure "namespaced" }}
        if (!(window as any).{{ .JSNamespace }}) {
            throw new Error('WASM APIs not found - module may not have loaded correctly');
        }
        this.wasm = (window as any).{{ .JSNamespace }};
{{- else if eq .APIStructure "flat" }}
        {{- $firstService := index .Services 0 }}
        {{- $firstMethod := index $firstService.Methods 0 }}
        if (!(window as any).{{ .JSNamespace }}{{ $firstMethod.Name }}) {
            throw new Error('WASM APIs not found - module may not have loaded correctly');
        }
        this.wasm = window as any;
{{- else if eq .APIStructure "service_based" }}
        if (!(window as any).services) {
            throw new Error('WASM APIs not found - module may not have loaded correctly');
        }
        this.wasm = (window as any).services;
{{- end }}

        console.log('{{ .ModuleName }} WASM module loaded successfully');
    }

    /**
     * Ensure WASM module is loaded (synchronous version for service calls)
     */
    private ensureWASMLoaded(): void {
        if (!this.isReady()) {
            throw new Error('WASM module not loaded. Call loadWasm() and waitUntilReady() first.');
        }
    }

    /**
     * Get WASM method function by path
     */
    private getWasmMethod(methodPath: string): Function {
{{- if eq .APIStructure "namespaced" }}
        // Handle namespaced structure: namespace.service.method
        const parts = methodPath.split('.');
        let current = this.wasm;
        for (const part of parts) {
            current = current[part];
            if (!current) {
                throw new Error(`Method not found: ${methodPath}`);
            }
        }
        return current;
{{- else if eq .APIStructure "flat" }}
        // Handle flat structure: direct method name
        const method = this.wasm[methodPath];
        if (!method) {
            throw new Error(`Method not found: ${methodPath}`);
        }
        return method;
{{- else if eq .APIStructure "service_based" }}
        // Handle service-based structure: services.service.method
        const parts = methodPath.split('.');
        let current = this.wasm;
        for (const part of parts) {
            current = current[part];
            if (!current) {
                throw new Error(`Method not found: ${methodPath}`);
            }
        }
        return current;
{{- end }}
    }

    /**
     * Convert request to JSON with custom handling
     */
    private convertToJson(request: any): any {
        // First try native toJson/toJSON methods
        const nativeMethod = this.detectToJson(request);
        if (nativeMethod !== this.fallbackToJson) {
            const result = nativeMethod(request);
            return this.applyCustomConversions(result, 'request');
        }
        
        // Use fallback with custom conversions
        return this.applyCustomConversions(
            this.fallbackToJson(request),
            'request'
        );
    }

    /**
     * Convert response from JSON with custom handling
     */
    private convertFromJson(json: any, constructor: any): any {
        // Apply custom conversions before native parsing
        const processedJson = this.applyCustomConversions(json, 'response');
        
        // Try native fromJson/fromJSON methods
        const nativeMethod = this.detectFromJson(constructor);
        if (nativeMethod !== this.fallbackFromJson) {
            return nativeMethod(processedJson);
        }
        
        // Use fallback
        return this.fallbackFromJson(processedJson);
    }

    /**
     * Apply custom conversions for better Go compatibility
     */
    private applyCustomConversions(obj: any, direction: 'request' | 'response'): any {
        if (!obj || typeof obj !== 'object') {
            return obj;
        }

        const result: any = Array.isArray(obj) ? [] : {};

        for (const [key, value] of Object.entries(obj)) {
            let processedKey = key;
            let processedValue = value;

            // Apply field name transformation if configured
            if (this.conversionOptions.fieldTransformer) {
                processedKey = this.conversionOptions.fieldTransformer(key);
            }

            // Handle oneof fields
            if (this.conversionOptions.handleOneofs && this.isOneofField(obj, key)) {
                // For oneofs, we might need to flatten the structure
                if (direction === 'request' && value && typeof value === 'object') {
                    // Flatten oneof for Go: { oneofField: { actualField: value } } -> { actualField: value }
                    const oneofEntries = Object.entries(value);
                    if (oneofEntries.length === 1) {
                        const [innerKey, innerValue] = oneofEntries[0];
                        processedKey = innerKey;
                        processedValue = this.applyCustomConversions(innerValue, direction);
                    }
                }
            } else if (value !== null && typeof value === 'object') {
                // Recursively process nested objects
                processedValue = this.applyCustomConversions(value, direction);
            } else if (typeof value === 'bigint' && direction === 'request') {
                // Handle BigInt serialization
                processedValue = this.conversionOptions.bigIntHandler
                    ? this.conversionOptions.bigIntHandler(value)
                    : value.toString();
            } else if (typeof value === 'string' && /^\d+$/.test(value) && direction === 'response') {
                // Potentially handle BigInt deserialization based on field context
                // This would need more sophisticated field type tracking
                processedValue = value;
            }

            // Handle default values
            if (!this.conversionOptions.emitDefaults && 
                direction === 'request' && 
                this.isDefaultValue(processedValue)) {
                continue;
            }

            result[processedKey] = processedValue;
        }

        return result;
    }

    /**
     * Check if a field might be a oneof
     * This is a heuristic - ideally we'd have type information
     */
    private isOneofField(parent: any, fieldName: string): boolean {
        // Common patterns for oneof fields in protobuf-es:
        // 1. Field name pattern (e.g., ends with 'Case' or starts with 'oneof')
        // 2. Object with single property that's not a common type
        const value = parent[fieldName];
        
        if (!value || typeof value !== 'object' || Array.isArray(value)) {
            return false;
        }
        
        const keys = Object.keys(value);
        // Oneof typically has exactly one field set
        if (keys.length === 1) {
            // Additional heuristics could be added here
            return true;
        }
        
        return false;
    }

    /**
     * Check if a value is a default value that should be omitted
     */
    private isDefaultValue(value: any): boolean {
        return value === null || 
               value === undefined || 
               value === '' || 
               value === 0 || 
               value === false ||
               (Array.isArray(value) && value.length === 0) ||
               (typeof value === 'object' && Object.keys(value).length === 0);
    }

    /**
     * Fallback toJson implementation
     */
    private fallbackToJson(obj: any): any {
        return JSON.parse(JSON.stringify(obj, (key, value) => {
            if (typeof value === 'bigint') {
                return this.conversionOptions.bigIntHandler
                    ? this.conversionOptions.bigIntHandler(value)
                    : value.toString();
            }
            return value;
        }));
    }

    /**
     * Fallback fromJson implementation
     */
    private fallbackFromJson(json: any): any {
        // Simple pass-through for objects that don't have fromJson
        return json;
    }

    /**
     * Auto-detect toJson conversion method
     */
    private detectToJson(request: any): (req: any) => any {
{{- if eq .Config.TSGenerator "protoc-gen-es" }}
        return (request as any).toJson || 
               (request as any).toJSON || 
               this.fallbackToJson.bind(this);
{{- else if eq .Config.TSGenerator "protoc-gen-ts" }}
        return (request as any).toJSON || 
               (request as any).toJson || 
               this.fallbackToJson.bind(this);
{{- else }}
        // Generic fallback
        return (request as any).toJson || 
               (request as any).toJSON || 
               this.fallbackToJson.bind(this);
{{- end }}
    }

    /**
     * Auto-detect fromJson conversion method
     */
    private detectFromJson(constructor: any): (json: any) => any {
{{- if eq .Config.TSGenerator "protoc-gen-es" }}
        return constructor.fromJson || 
               constructor.fromJSON || 
               this.fallbackFromJson.bind(this);
{{- else if eq .Config.TSGenerator "protoc-gen-ts" }}
        return constructor.fromJSON || 
               constructor.fromJson || 
               this.fallbackFromJson.bind(this);
{{- else }}
        // Generic fallback
        return constructor.fromJson || 
               constructor.fromJSON || 
               this.fallbackFromJson.bind(this);
{{- end }}
    }
}

{{- range .Services }}
	{{- $serviceName := .Name }}
	{{- $serviceJSName := .JSName }}
/**
 * {{ .Name }} service client implementation
 */
class {{ .Name }}ClientImpl implements {{ .Name }}Methods {
    constructor(private parent: {{ $.ModuleName | title }}Client) {}

	{{- range .Methods }}
		{{- if .ShouldGenerate }}
    async {{ .JSName }}(request: {{ .Name }}Request): Promise<{{ .Name }}Response> {
		{{- if eq $.APIStructure "namespaced" }}
        return this.parent.callMethod('{{ $serviceJSName }}.{{ .JSName }}', request);
		{{- else if eq $.APIStructure "flat" }}
        return this.parent.callMethod('{{ $.JSNamespace }}{{ .Name }}', request);
		{{- else if eq $.APIStructure "service_based" }}
        return this.parent.callMethod('{{ $serviceJSName }}.{{ .JSName }}', request);
		{{- end }}
    }
		{{- end }}
	{{- end }}
}
{{- end }}

// Export the main client class
export default {{ .ModuleName | title }}Client;
