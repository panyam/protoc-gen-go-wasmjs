// Code generated by protoc-gen-go-wasmjs. DO NOT EDIT.
// Browser Service Manager - Shared component for handling browser-provided services

/**
 * Browser Service Manager
 * Handles FIFO processing of browser service calls from WASM
 * This is a shared component used by all WASM clients that interact with browser services
 */
export class BrowserServiceManager {
    private processing = false;
    private serviceImplementations = new Map<string, any>();
    private wasmModule: any;

    constructor() {
        // WASM will set up the global functions __wasmGetNextBrowserCall and __wasmDeliverBrowserResponse
        // We'll just use them when they're available
    }

    /**
     * Register a browser service implementation
     */
    registerService(name: string, implementation: any): void {
        this.serviceImplementations.set(name, implementation);
    }

    /**
     * Set the WASM module reference
     */
    setWasmModule(wasmModule: any): void {
        this.wasmModule = wasmModule;
    }

    /**
     * Start processing browser service calls
     */
    async startProcessing(): Promise<void> {
        if (this.processing) return;
        this.processing = true;

        // Process calls in a loop
        while (this.processing) {
            const call = this.getNextBrowserCall();
            if (!call) {
                // No pending calls, wait a bit
                await new Promise(resolve => setTimeout(resolve, 10));
                continue;
            }

            // Process each call asynchronously without blocking the loop
            this.processCall(call);
        }
    }

    /**
     * Process a single browser service call asynchronously
     */
    private async processCall(call: any): Promise<void> {
        try {
            // Get the service implementation
            const service = this.serviceImplementations.get(call.service);
            if (!service) {
                throw new Error(`No implementation registered for service: ${call.service}`);
            }

            // Get the method
            const methodName = call.method.charAt(0).toLowerCase() + call.method.slice(1);
            const method = service[methodName];
            if (!method) {
                throw new Error(`Method ${methodName} not found on service ${call.service}`);
            }

            // Parse request
            const request = JSON.parse(call.request);

            // Call the method (auto-await if async)
            const response = await Promise.resolve(method.call(service, request));

            // Deliver response
            this.deliverBrowserResponse(call.id, JSON.stringify(response), null);
        } catch (error: any) {
            // Deliver error
            this.deliverBrowserResponse(call.id, null, error.message || String(error));
        }
    }

    /**
     * Stop processing browser service calls
     */
    stopProcessing(): void {
        this.processing = false;
    }

    /**
     * Get the next browser call from WASM
     */
    private getNextBrowserCall(): any {
        // The __wasmGetNextBrowserCall function should be provided by WASM
        if (typeof (window as any).__wasmGetNextBrowserCall === 'function') {
            return (window as any).__wasmGetNextBrowserCall();
        }
        return null;
    }

    /**
     * Deliver a response back to WASM (called internally)
     */
    private deliverBrowserResponse(callId: string, response: string | null, error: string | null): boolean {
        if (!(window as any).__wasmDeliverBrowserResponse) {
            return false;
        }
        return (window as any).__wasmDeliverBrowserResponse(callId, response, error);
    }
}

// Export as default as well for convenience
export default BrowserServiceManager;