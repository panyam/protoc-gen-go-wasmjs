// Code generated by protoc-gen-go-wasmjs. DO NOT EDIT.
// source: {{ .SourcePath }}

import { WASMBundle, WASMBundleConfig, ServiceClient } from '@protoc-gen-go-wasmjs/runtime';
{{- if .TypeImports }}

// Import TypeScript types for method signatures
import {
{{- range .TypeImports }}
    {{ . }},
{{- end }}
} from './interfaces';
{{- end }}

{{- range .Services }}
/**
 * {{ .Name }} service client interface
 * Fully typed method signatures with TypeScript interfaces
 */
export interface {{ .Name }}Methods {
	{{- range .Methods }}
		{{- if .ShouldGenerate }}
			{{- if .IsServerStreaming }}
	{{ .JSName }}(request: {{ .RequestTSType }}, callback: (response: {{ .ResponseTSType }} | null, error: string | null, done: boolean) => boolean): void;
			{{- else if .IsAsync }}
	{{ .JSName }}(request: {{ .RequestTSType }}, callback: (response: {{ .ResponseTSType }}, error?: string) => void): Promise<void>;
			{{- else }}
	{{ .JSName }}(request: {{ .RequestTSType }}): Promise<{{ .ResponseTSType }}>;
			{{- end }}
		{{- end }}
	{{- end }}
}
{{- end }}

{{- if .HasBrowserClients }}

// =============================================================================
// Browser Service Interfaces
// =============================================================================

{{- range .BrowserClients }}
/**
 * {{ .Name }} browser service interface
 * Implement this interface to provide browser functionality to WASM
 */
export interface {{ .Name }}Server {
	{{- range .Methods }}
		{{- if .ShouldGenerate }}
	{{ .JSName }}(request: any): Promise<any> | any;
		{{- end }}
	{{- end }}
}
{{- end }}
{{- end }}

/**
 * {{ .ModuleName }} WASM bundle - manages shared WASM module
 * One bundle per WASM file, shared by multiple service clients
 */
export class {{ .ModuleName | title }}Bundle {
    private wasmBundle: WASMBundle;

    // Service clients that share this bundle
{{- range .Services }}
    public readonly {{ .JSName }}: {{ .Name }}ServiceClient;
{{- end }}

    constructor() {
        const config: WASMBundleConfig = {
            moduleName: '{{ .ModuleName }}',
            apiStructure: '{{ .APIStructure }}',
            jsNamespace: '{{ .JSNamespace }}'
        };

        this.wasmBundle = new WASMBundle(config);

        // Initialize service clients with shared bundle
{{- range .Services }}
        this.{{ .JSName }} = new {{ .Name }}ServiceClient(this.wasmBundle);
{{- end }}
    }

    /**
     * Register a browser service implementation
     */
    public registerBrowserService(name: string, implementation: any): void {
        this.wasmBundle.registerBrowserService(name, implementation);
    }

    /**
     * Load the WASM module asynchronously (singleton pattern)
     */
    public async loadWasm(wasmPath: string): Promise<void> {
        return this.wasmBundle.loadWasm(wasmPath);
    }

    /**
     * Check if WASM bundle is ready for operations
     */
    public isReady(): boolean {
        return this.wasmBundle.isReady();
    }

    /**
     * Wait for WASM bundle to be ready
     */
    public async waitUntilReady(): Promise<void> {
        return this.wasmBundle.waitUntilReady();
    }
}

{{- range .Services }}
	{{- $serviceName := .Name }}
	{{- $serviceJSName := .JSName }}
/**
 * {{ .Name }} service client implementation
 * Lightweight facade that uses shared WASM bundle
 */
export class {{ .Name }}ServiceClient extends ServiceClient implements {{ .Name }}Methods {
	{{- range .Methods }}
		{{- if .ShouldGenerate }}
			{{- if .IsServerStreaming }}
    {{ .JSName }}(
        request: {{ .RequestTSType }},
        callback: (response: {{ .ResponseTSType }} | null, error: string | null, done: boolean) => boolean
    ): void {
				{{- if eq $.APIStructure "namespaced" }}
        return this.callStreamingMethod('{{ $serviceJSName }}.{{ .JSName }}', request, callback);
				{{- else if eq $.APIStructure "flat" }}
        return this.callStreamingMethod('{{ $.JSNamespace }}{{ .Name }}', request, callback);
				{{- else if eq $.APIStructure "service_based" }}
        return this.callStreamingMethod('{{ $serviceJSName }}.{{ .JSName }}', request, callback);
				{{- end }}
    }
			{{- else if .IsAsync }}
    async {{ .JSName }}(request: {{ .RequestTSType }}, callback: (response: {{ .ResponseTSType }}, error?: string) => void): Promise<void> {
				{{- if eq $.APIStructure "namespaced" }}
        return this.callMethodWithCallback('{{ $serviceJSName }}.{{ .JSName }}', request, callback);
				{{- else if eq $.APIStructure "flat" }}
        return this.callMethodWithCallback('{{ $.JSNamespace }}{{ .Name }}', request, callback);
				{{- else if eq $.APIStructure "service_based" }}
        return this.callMethodWithCallback('{{ $serviceJSName }}.{{ .JSName }}', request, callback);
				{{- end }}
    }
			{{- else }}
    async {{ .JSName }}(request: {{ .RequestTSType }}): Promise<{{ .ResponseTSType }}> {
				{{- if eq $.APIStructure "namespaced" }}
        return this.callMethod('{{ $serviceJSName }}.{{ .JSName }}', request);
				{{- else if eq $.APIStructure "flat" }}
        return this.callMethod('{{ $.JSNamespace }}{{ .Name }}', request);
				{{- else if eq $.APIStructure "service_based" }}
        return this.callMethod('{{ $serviceJSName }}.{{ .JSName }}', request);
				{{- end }}
    }
			{{- end }}
		{{- end }}
	{{- end }}
}
{{- end }}

// Export the main bundle class as default
export default {{ .ModuleName | title }}Bundle;
