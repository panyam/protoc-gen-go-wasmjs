// Code generated by protoc-gen-go-wasmjs. DO NOT EDIT.
// source: {{ .SourcePath }}

import { BrowserServiceManager, WASMResponse, WasmError, WASMServiceClient } from '@protoc-gen-go-wasmjs/runtime';

{{- range .Services }}
/**
 * {{ .Name }} service client interface
 * Uses any types since we generate our own TypeScript interfaces
 */
export interface {{ .Name }}Methods {
	{{- range .Methods }}
		{{- if .ShouldGenerate }}
			{{- if .IsServerStreaming }}
	{{ .JSName }}(request: any, callback: (response: any | null, error: string | null, done: boolean) => boolean): void;
			{{- else if .IsAsync }}
	{{ .JSName }}(request: any, callback: (response: any, error?: string) => void): Promise<void>;
			{{- else }}
	{{ .JSName }}(request: any): Promise<any>;
			{{- end }}
		{{- end }}
	{{- end }}
}
{{- end }}

{{- if .HasBrowserServices }}

// =============================================================================
// Browser Service Interfaces
// =============================================================================

{{- range .BrowserServices }}
/**
 * {{ .Name }} browser service interface
 * Implement this interface to provide browser functionality to WASM
 */
export interface {{ .Name }}Server {
	{{- range .Methods }}
		{{- if .ShouldGenerate }}
	{{ .JSName }}(request: any): Promise<any> | any;
		{{- end }}
	{{- end }}
}
{{- end }}
{{- end }}

// Base WASMServiceClient functionality is now imported from @protoc-gen-go-wasmjs/runtime

/**
 * {{ .ModuleName }} WASM client
 * Provides a clean interface between UI components and the Go WASM service implementations
 */
export class {{ .ModuleName | title }}Client extends WASMServiceClient {
    // Service-specific clients
{{- range .Services }}
    public readonly {{ .JSName }}: {{ .Name }}ClientImpl;
{{- end }}

    constructor() {
        super();
{{- range .Services }}
        this.{{ .JSName }} = new {{ .Name }}ClientImpl(this);
{{- end }}
    }

    /**
     * Load the WASM module asynchronously
     */
    public async loadWasm(wasmPath: string = './{{ .ModuleName }}.wasm'): Promise<void> {
        if (this.wasmLoadPromise) {
            return this.wasmLoadPromise;
        }

        this.wasmLoadPromise = this.loadWASMModule(wasmPath);
        return this.wasmLoadPromise;
    }

    /**
     * Load the WASM module implementation
     */
    private async loadWASMModule(wasmPath: string): Promise<void> {
        console.log('Loading {{ .ModuleName }} WASM module...');

        // Check if WASM is already loaded (for testing environments) 
{{- if eq .APIStructure "namespaced" }}
        if ((window as any).{{ .JSNamespace }}) {
            console.log('WASM module already loaded (pre-loaded in test environment)');
            this.wasm = (window as any).{{ .JSNamespace }};
            return;
        }
{{- else if eq .APIStructure "flat" }}
        // Check for any flat function to determine if loaded
        {{- $firstService := index .Services 0 }}
        {{- $firstMethod := index $firstService.Methods 0 }}
        if ((window as any).{{ .JSNamespace }}{{ $firstMethod.Name }}) {
            console.log('WASM module already loaded (pre-loaded in test environment)');
            this.wasm = window as any;
            return;
        }
{{- else if eq .APIStructure "service_based" }}
        if ((window as any).services) {
            console.log('WASM module already loaded (pre-loaded in test environment)');
            this.wasm = (window as any).services;
            return;
        }
{{- end }}

        // Load Go's WASM support
        if (!(window as any).Go) {
            const script = document.createElement('script');
            script.src = '/static/wasm/wasm_exec.js';
            document.head.appendChild(script);

            await new Promise<void>((resolve, reject) => {
                script.onload = () => resolve();
                script.onerror = () => reject(new Error('Failed to load wasm_exec.js'));
            });
        }

        // Initialize Go WASM runtime
        const go = new (window as any).Go();
        const wasmModule = await WebAssembly.instantiateStreaming(
            fetch(wasmPath),
            go.importObject
        );

        // Run the WASM module
        go.run(wasmModule.instance);

        // Start browser service manager (always available for cross-package browser services)
        if (this.browserServiceManager) {
            this.browserServiceManager.setWasmModule(window);
            this.browserServiceManager.startProcessing();
        }

        // Verify WASM APIs are available
{{- if eq .APIStructure "namespaced" }}
        if (!(window as any).{{ .JSNamespace }}) {
            throw new Error('WASM APIs not found - module may not have loaded correctly');
        }
        this.wasm = (window as any).{{ .JSNamespace }};
{{- else if eq .APIStructure "flat" }}
        {{- $firstService := index .Services 0 }}
        {{- $firstMethod := index $firstService.Methods 0 }}
        if (!(window as any).{{ .JSNamespace }}{{ $firstMethod.Name }}) {
            throw new Error('WASM APIs not found - module may not have loaded correctly');
        }
        this.wasm = window as any;
{{- else if eq .APIStructure "service_based" }}
        if (!(window as any).services) {
            throw new Error('WASM APIs not found - module may not have loaded correctly');
        }
        this.wasm = (window as any).services;
{{- end }}

        console.log('{{ .ModuleName }} WASM module loaded successfully');
    }

    /**
     * Get WASM method function by path (required by base class)
     */
    protected getWasmMethod(methodPath: string): Function {
{{- if eq .APIStructure "namespaced" }}
        // Handle namespaced structure: namespace.service.method
        const parts = methodPath.split('.');
        let current = this.wasm;
        for (const part of parts) {
            current = current[part];
            if (!current) {
                throw new Error(`Method not found: ${methodPath}`);
            }
        }
        return current;
{{- else if eq .APIStructure "flat" }}
        // Handle flat structure: direct method name
        const method = this.wasm[methodPath];
        if (!method) {
            throw new Error(`Method not found: ${methodPath}`);
        }
        return method;
{{- else if eq .APIStructure "service_based" }}
        // Handle service-based structure: services.service.method
        const parts = methodPath.split('.');
        let current = this.wasm;
        for (const part of parts) {
            current = current[part];
            if (!current) {
                throw new Error(`Method not found: ${methodPath}`);
            }
        }
        return current;
{{- end }}
    }
}

{{- range .Services }}
	{{- $serviceName := .Name }}
	{{- $serviceJSName := .JSName }}
/**
 * {{ .Name }} service client implementation
 */
class {{ .Name }}ClientImpl implements {{ .Name }}Methods {
    constructor(private parent: {{ $.ModuleName | title }}Client) {}

	{{- range .Methods }}
		{{- if .ShouldGenerate }}
			{{- if .IsServerStreaming }}
    {{ .JSName }}(
        request: any,
        callback: (response: any | null, error: string | null, done: boolean) => boolean
    ): void {
				{{- if eq $.APIStructure "namespaced" }}
        return this.parent.callStreamingMethod('{{ $serviceJSName }}.{{ .JSName }}', request, callback);
				{{- else if eq $.APIStructure "flat" }}
        return this.parent.callStreamingMethod('{{ $.JSNamespace }}{{ .Name }}', request, callback);
				{{- else if eq $.APIStructure "service_based" }}
        return this.parent.callStreamingMethod('{{ $serviceJSName }}.{{ .JSName }}', request, callback);
				{{- end }}
    }
			{{- else if .IsAsync }}
    async {{ .JSName }}(request: any, callback: (response: any, error?: string) => void): Promise<void> {
				{{- if eq $.APIStructure "namespaced" }}
        return this.parent.callMethodWithCallback('{{ $serviceJSName }}.{{ .JSName }}', request, callback);
				{{- else if eq $.APIStructure "flat" }}
        return this.parent.callMethodWithCallback('{{ $.JSNamespace }}{{ .Name }}', request, callback);
				{{- else if eq $.APIStructure "service_based" }}
        return this.parent.callMethodWithCallback('{{ $serviceJSName }}.{{ .JSName }}', request, callback);
				{{- end }}
    }
			{{- else }}
    async {{ .JSName }}(request: any): Promise<any> {
				{{- if eq $.APIStructure "namespaced" }}
        return this.parent.callMethod('{{ $serviceJSName }}.{{ .JSName }}', request);
				{{- else if eq $.APIStructure "flat" }}
        return this.parent.callMethod('{{ $.JSNamespace }}{{ .Name }}', request);
				{{- else if eq $.APIStructure "service_based" }}
        return this.parent.callMethod('{{ $serviceJSName }}.{{ .JSName }}', request);
				{{- end }}
    }
			{{- end }}
		{{- end }}
	{{- end }}
}
{{- end }}

// Re-export BrowserServiceManager for cross-package use
export { BrowserServiceManager };

// Export the main client class as default
export default {{ .ModuleName | title }}Client;
