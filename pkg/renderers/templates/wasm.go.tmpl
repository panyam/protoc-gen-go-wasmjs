//go:build js && wasm
// +build js,wasm

// Code generated by protoc-gen-go-wasmjs. DO NOT EDIT.
// source: {{ .SourcePath }}

package {{ .ModuleName }}

import (
{{- if or .HasServices .HasBrowserClients }}
	"context"
{{- end }}
{{- if .HasServices }}
	"encoding/json"
{{- end }}
	"fmt"
	"syscall/js"
{{- if .HasServices }}
	"time"

	"github.com/panyam/protoc-gen-go-wasmjs/pkg/wasm"
	"google.golang.org/grpc/metadata"
{{- end }}
{{- range .Imports }}
	{{ .Alias }} {{ .Path | printf "%q" }}
{{- end }}
)

// {{ .PackageName | replaceAll "." "_" | title }}ServicesExports provides WASM exports for dependency injection
type {{ .PackageName | replaceAll "." "_" | title }}ServicesExports struct {
{{- range .Services }}
	{{ .Name }} {{ .GoType }}
{{- end }}
{{- if .HasBrowserClients }}

	// Browser-provided services (clients)
{{- range .BrowserClients }}
	{{ .Name }} *{{ .Name }}Client
{{- end }}
{{- end }}
}

// RegisterAPI registers the services with the JavaScript global namespace
func (exports *{{ .PackageName | replaceAll "." "_" | title }}ServicesExports) RegisterAPI() {
	fmt.Println("{{ .ModuleName }} WASM module loading...")
{{- if .HasBrowserClients }}

	// Initialize browser channel for browser-provided services
	_ = wasm.GetBrowserChannel()
{{- end }}

{{- if eq .APIStructure "namespaced" }}
	// Create namespaced API structure
	{{ .JSNamespace }} := map[string]interface{}{
	{{- range .Services }}
		"{{ .JSName }}": map[string]interface{}{
		{{- range .Methods }}
			{{- if .ShouldGenerate }}
			"{{ .JSName }}": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.{{ .GoFuncName }}(this, args)
			}),
			{{- end }}
		{{- end }}
		},
	{{- end }}
	}
	js.Global().Set("{{ .JSNamespace }}", js.ValueOf({{ .JSNamespace }}))
{{- else if eq .APIStructure "flat" }}
	// Create flat API structure
	{{- range .Services }}
		{{- range .Methods }}
			{{- if .ShouldGenerate }}
	js.Global().Set("{{ $.JSNamespace }}{{ .Name }}", js.FuncOf(func(this js.Value, args []js.Value) any {
		return exports.{{ .GoFuncName }}(this, args)
	}))
			{{- end }}
		{{- end }}
	{{- end }}
{{- else if eq .APIStructure "service_based" }}
	// Create service-based API structure
	services := map[string]interface{}{
	{{- range .Services }}
		"{{ .JSName }}": map[string]interface{}{
		{{- range .Methods }}
			{{- if .ShouldGenerate }}
			"{{ .JSName }}": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.{{ .GoFuncName }}(this, args)
			}),
			{{- end }}
		{{- end }}
		},
	{{- end }}
	}
	js.Global().Set("services", js.ValueOf(services))
{{- end }}

	fmt.Println("{{ .ModuleName }} WASM module loaded successfully")
}

// =============================================================================
// WASM API Functions - Generated Method Wrappers
// =============================================================================

{{- range .Services }}
	{{- $serviceName := .Name }}
	{{- range .Methods }}
		{{- if .ShouldGenerate }}

// {{ .GoFuncName }} handles the {{ .Name }} method for {{ $serviceName }}
func (exports *{{ $.PackageName | replaceAll "." "_" | title }}ServicesExports) {{ .GoFuncName }}(this js.Value, args []js.Value) any {
	if exports.{{ $serviceName }} == nil {
		return createJSResponse(false, "{{ $serviceName }} not initialized", nil)
	}

	{{- if .IsServerStreaming }}
	// Server streaming method: expect request JSON and callback function
	if len(args) < 2 {
		return createJSResponse(false, "Request JSON and callback function required for streaming method", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	callback := args[1]
	if callback.Type() != js.TypeFunction {
		return createJSResponse(false, "Second argument must be a callback function", nil)
	}

	// Parse request
	req := &{{ .RequestType }}{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true,
	}); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Start streaming in goroutine to avoid blocking
	go func() {
		ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
		defer cancel()

		// Create a stream wrapper for server-side streaming
		streamWrapper := &serverStreamWrapper{{ .Name }}{
			ctx: ctx,
			callback: callback,
		}

		// Call the server streaming method
		err := exports.{{ $serviceName }}.{{ .Name }}(req, streamWrapper)
		if err != nil {
			// Call callback with error and done=true
			callback.Invoke(js.Null(), err.Error(), true)
			return
		}

		// Signal completion
		callback.Invoke(js.Null(), js.Null(), true)
	}()

	// Return immediately for streaming methods
	return createJSResponse(true, "Server streaming started", nil)
	{{- else if .IsAsync }}
	// Async method: expect request JSON and callback function
	if len(args) < 2 {
		return createJSResponse(false, "Request JSON and callback function required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	callback := args[1]
	if callback.Type() != js.TypeFunction {
		return createJSResponse(false, "Second argument must be a callback function", nil)
	}

	// Parse request
	req := &{{ .RequestType }}{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true,
	}); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Call service method in goroutine to avoid blocking
	go func() {
		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()

		// Call service method
		resp, err := exports.{{ $serviceName }}.{{ .Name }}(ctx, req)
		
		if err != nil {
			// Call callback with error
			callback.Invoke(js.Null(), err.Error())
			return
		}

		// Marshal response
		responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
			UseProtoNames:   false,
			EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
			UseEnumNumbers:  false,
		})
		if err != nil {
			callback.Invoke(js.Null(), fmt.Sprintf("Failed to marshal response: %v", err))
			return
		}

		// Convert JSON to JavaScript object and call callback
		var jsObject interface{}
            if err := json.Unmarshal(responseJSON, &jsObject); err != nil {
                callback.Invoke(js.Null(), fmt.Sprintf("Failed to convert response to JS object: %v", err))
                return
            }
            callback.Invoke(js.ValueOf(jsObject), js.Null())
	}()

	// Return immediately for async methods
	return createJSResponse(true, "Async operation started", nil)
	{{- else }}
	// Synchronous method
	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	req := &{{ .RequestType }}{}
	marshaller := wasm.GetGlobalMarshaller()
	if err := marshaller.Unmarshal([]byte(requestJSON), req, wasm.UnmarshalOptions{
		DiscardUnknown: true,
		AllowPartial:   true, // Allow partial messages for better compatibility
	}); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.{{ $serviceName }}.{{ .Name }}(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response with options for better TypeScript compatibility
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false, // Use JSON names (camelCase) instead of proto names
		EmitUnpopulated: true,  // Emit zero values to avoid undefined in JavaScript
		UseEnumNumbers:  false, // Use enum string values
	})
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
	{{- end }}
}
		{{- end }}
	{{- end }}
{{- end }}

{{- if .Services }}
// =============================================================================
// Server Stream Wrappers
// =============================================================================

{{- range .Services }}
{{- range .Methods }}
{{- if .IsServerStreaming }}

// serverStreamWrapper{{ .Name }} implements the server stream interface for {{ .Name }}
type serverStreamWrapper{{ .Name }} struct {
	ctx context.Context
	callback js.Value
}

func (s *serverStreamWrapper{{ .Name }}) Send(resp *{{ .ResponseType }}) error {
	// Marshal response
	marshaller := wasm.GetGlobalMarshaller()
	responseJSON, err := marshaller.Marshal(resp, wasm.MarshalOptions{
		UseProtoNames:   false,
		EmitUnpopulated: false,
		UseEnumNumbers:  false,
	})
	if err != nil {
		s.callback.Invoke(js.Null(), fmt.Sprintf("Failed to marshal response: %v", err), true)
		return err
	}

	// Call callback with response, no error, not done - returns boolean to continue
	shouldContinue := s.callback.Invoke(string(responseJSON), js.Null(), false)

	// Check if JS wants to stop the stream
	if !shouldContinue.Bool() {
		return fmt.Errorf("stream cancelled by client")
	}

	return nil
}

func (s *serverStreamWrapper{{ .Name }}) Context() context.Context {
	return s.ctx
}

// Implement other required methods for the stream interface
func (s *serverStreamWrapper{{ .Name }}) SetHeader(metadata.MD) error { return nil }
func (s *serverStreamWrapper{{ .Name }}) SendHeader(metadata.MD) error { return nil }
func (s *serverStreamWrapper{{ .Name }}) SetTrailer(metadata.MD) {}
func (s *serverStreamWrapper{{ .Name }}) SendMsg(m interface{}) error {
	if msg, ok := m.(*{{ .ResponseType }}); ok {
		return s.Send(msg)
	}
	return fmt.Errorf("unexpected message type")
}
func (s *serverStreamWrapper{{ .Name }}) RecvMsg(m interface{}) error { return nil }

{{- end }}
{{- end }}
{{- end }}
{{- end }}

// =============================================================================
// Helper Functions
// =============================================================================

// createJSResponse is a wrapper for the library function
func createJSResponse(success bool, message string, data any) any {
{{- if or .HasServices .HasBrowserClients }}
	return wasm.CreateJSResponse(success, message, data)
{{- else }}
	// Inline implementation when no wasm import needed
	response := map[string]any{
		"success": success,
		"message": message,
		"data":    data,
	}

	responseBytes, err := json.Marshal(response)
	if err != nil {
		fmt.Printf("Failed to marshal JSON response: %v\n", err)
		errorResponse := map[string]any{
			"success": false,
			"message": fmt.Sprintf("JSON marshal error: %v", err),
			"data":    nil,
		}
		errorBytes, _ := json.Marshal(errorResponse)
		return js.Global().Get("JSON").Call("parse", string(errorBytes))
	}

	return js.Global().Get("JSON").Call("parse", string(responseBytes))
{{- end }}
}

{{- if .HasBrowserClients }}

// =============================================================================
// Browser Service Client Implementations
// =============================================================================

{{- range $service := .BrowserClients }}

// {{ $service.Name }}Client is a client for the browser-provided {{ $service.Name }} service
type {{ $service.Name }}Client struct {
	channel *wasm.BrowserServiceChannel
}

// New{{ $service.Name }}Client creates a new client for the browser-provided {{ $service.Name }} service
func New{{ $service.Name }}Client() *{{ $service.Name }}Client {
	return &{{ $service.Name }}Client{
		channel: wasm.GetBrowserChannel(),
	}
}

{{- range .Methods }}

// {{ .Name }} calls the browser-provided {{ .Name }} method
func (c *{{ $service.Name }}Client) {{ .Name }}(ctx context.Context, req *{{ .RequestType }}) (*{{ .ResponseType }}, error) {
{{- if .IsAsync }}
	// This is an async browser method (returns a Promise in JavaScript)
	return wasm.CallBrowserServiceAsync[*{{ .RequestType }}, *{{ .ResponseType }}](
		c.channel, ctx, "{{ $service.Name }}", "{{ .JSName }}", req,
	)
{{- else }}
	// This is a synchronous browser method
	return wasm.CallBrowserService[*{{ .RequestType }}, *{{ .ResponseType }}](
		c.channel, ctx, "{{ $service.Name }}", "{{ .JSName }}", req,
	)
{{- end }}
}
{{- end }}
{{- end }}
{{- end }}
